---
title: "kaggle_housesale"
author: "RenardBao"
date: "2018年12月24日"
output: 
  html_document:
    theme: journal
    toc: true
    toc_depth: 5
    toc_float:
      collapsed: TRUE
      smooth_scroll: TRUE
---
```{r,include=FALSE}
knitr::opts_knit$set(root.dir ="D:/r_project/data-analysis/house_sale_predict")

```

<style> p{line-height: 2em;}</style>
# 前言
> Ask a home buyer to describe their dream house, and they probably won't begin with the height of the basement ceiling or the proximity to an east-west railroad. But this playground competition's dataset proves that much more influences price negotiations than the number of bedrooms or a white-picket fence.  

>  With 79 explanatory variables describing (almost) every aspect of residential homes in Ames, Iowa, this competition challenges you to predict the final price of each home.


這次的資料是來自於[Kaggle](https://www.kaggle.com/c/house-prices-advanced-regression-techniques)，題目是要預測美國愛荷華州的埃姆斯城市的房價。我會進行資料探索、特徵工程和一些資料視覺，最後我會運用LASSO迴歸、XGBoost和SVM來建模，目前我是第657名(TOP13%)，但是隨著時間流逝大概會一直持續下降吧......

# 前置作業

以下是這次會用到的套件
```{r, result = "hide",warning=FALSE,message=FALSE}
library(ggplot2)
library(dplyr)
library(corrplot)
library(caret)
library(gridExtra)
library(scales)
library(ggrepel)
library(randomForest)
library(xgboost)
library(magrittr)
library(stringr)
library(knitr) #for html table
library(kableExtra) #for kable adjust
library(Cairo)
library(showtext) #ggplot 中文問題
```


先做一些環境設置。

```{r}
source('function.R')
options(scipen = 999)
train <- read.csv("data/train.csv", stringsAsFactors = F)
test <- read.csv("data/test.csv", stringsAsFactors = F)
#之後submission要用到test$id
test_labels <- test$Id
#test資料集沒有saleprice,用NA填補
test$SalePrice <- NA
all <- rbind(train, test)
dim(all)
```


瞄一下資料的結構

```{r}
#因為有長達80個變數,這邊先簡單顯示前15個跟目標變數
str(all[,c(1:15,80)])
```

```{r,message=FALSE,warning=FALSE}
num_var <-  sapply(all, is.numeric) %>% which %>% names()
char_var <- sapply(all, is.character) %>% which %>% names()
cat("數值變數有",length(num_var),"個",",類別變數有",length(char_var),"個")
```

# 初步探索資料
## 目標變數--銷售價格

看下圖可以發現我們的目標變數"銷售價格"，是一個明顯的右偏峰態。想一想其實也很合理，市場上絕大多數的消費者都負擔不起昂貴的房子。如果圖形呈現左偏或者常態峰佈，代表該地區房價偏貴，或許是屬於高級住宅區也不一定。後面我會將銷售價格做log處理將數據轉換成比較符合常態分佈。
```{r saleprice plot}
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot(aes(x = SalePrice )) + 
  geom_histogram(fill="deeppink2",
                 binwidth = 10000) +
  scale_x_continuous(breaks= seq(0, 800000, by=100000),
                     labels = comma)+
  theme_bw() + #去掉背景色
  theme(panel.grid=element_blank(),  #去掉網線
        panel.border=element_blank(),#去掉邊線
        axis.line=element_line(size=1,colour="black")) +
  annotation_custom(tableGrob(summary(all$SalePrice) %>%
                                "["(1:3) %>% as.matrix() %>% 
                                t,rows = NULL), 
                    xmin=400000, xmax=700000, 
                    ymin=75, ymax=150)+
  annotation_custom(tableGrob(summary(all$SalePrice) %>% 
                                round() %>%
                                "["(4:6) %>% 
                                as.matrix() %>% 
                                t,rows = NULL), 
                    xmin=400000, xmax=700000, 
                    ymin=75, ymax=100)



```

## 數值變數和目標變數的相關性
探索資料第二個步驟就是觀察各個變數和目標變數之間的相關性了，好讓我之後特徵工程比較好處理。

```{r corplot, fig.height = 9, fig.width = 9}
cor_numvar <- cor(all[, num_var], 
                  use="pairwise.complete.obs")
#排序之後挑出去相關性絕對值大於0.4的
cor_sortname <- 
  sort(cor_numvar[,'SalePrice'], 
       decreasing = TRUE) %>% 
  as.matrix() %>% 
  apply(1, function(x) abs(x)>0.4) %>% 
  which() %>% 
  names()
cor_numvar_sort <- cor_numvar[cor_sortname, cor_sortname]
#相關性視覺化
corrplot.mixed(cor_numvar_sort, tl.col="black", tl.pos = "lt")

```

透過上圖，相關性大於0.5的變數大概有10個、大於0.7則有兩個(OverallQual & GrLivArea)。後面剩餘的相關性章節我會再獨立出OverallQual & GrLivArea這兩個高相關性變數來個別視覺化其和目標變數的關係。

另外，變數間的共線性問題也要處理。例如GargeCars和GargeArea(0.89)、X1stFlrSF和TotalBsmtSF(0.8)、TotRmsAbvGrd和GrLivArea(0.81)、GarageYrBlt和YearBuilt(0.83)等等，這些會在後面特徵工程的部分進行處理。


## OverallQual
```{r OverallQual_visual, fig.height = 5, fig.width = 8,warning=F}
grid.arrange(all %>% filter(!(is.na(SalePrice))) %>% 
              ggplot(aes(x=factor(OverallQual), y=SalePrice))+
              geom_boxplot(col='dodgerblue2') + 
              labs(x='Overall Quality') +
              scale_y_continuous(breaks= seq(0, 800000, by=100000),
                                 labels = comma)+
              GGvisualize_theme(),
             all %>% filter(!(is.na(SalePrice))) %>% 
              ggplot(aes(x=OverallQual, y=SalePrice))+
              geom_point(col='dodgerblue2') + 
              geom_smooth(method = "lm", se=FALSE, color="deeppink3") +
              scale_x_continuous(breaks = seq(1,10,1))+
              scale_y_continuous(breaks= seq(0, 800000, by=100000), 
                                 labels = comma)+
              GGvisualize_theme())


```
OverallQual和銷售價格明顯的呈現正相關，而且OverallQual越高銷售價格距離也越大(離散程度)。從箱型圖上看來，沒有差異很大的離群值要踢掉，比較明顯的大概是OverallQual第4和第10。

## GrLivArea
```{r GrLivArea, fig.height = 10, fig.width = 14}
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot(aes(x=GrLivArea, y=SalePrice))+
  geom_point(col='dodgerblue2') + 
  geom_smooth(method = "lm", se=FALSE, color="deeppink3") +
  scale_y_continuous(breaks= seq(0, 800000, by=100000), 
                     labels = comma) +
  geom_text_repel(aes(label = ifelse(all$GrLivArea[!is.na(all$SalePrice)]>4500, 
                                     rownames(all), "")))+
               GGvisualize_theme()


```

看起來右下角似乎有怪異的離群值(524,299)，理論上來說居住坪數越高銷售價格應該也不會低到哪裡去。

```{r see_outlier}
#觀察outlier
all[c(524, 1299), c('SalePrice', 'GrLivArea', 'OverallQual')]

```

524和1299這對兄弟超奇怪的，OverallQual的分數為10、GrLivArea又是屬於前段班，照理來說房價應該會貴到天際才對。但是我在這邊暫時先不會踢掉這兩筆資料，他們會列入可疑名單並在後續特徵工程的時候會再拿出來討論，畢竟貿然地踢掉資料是一個奢侈又高風險的行為。

## 觀察NA值
來看看哪些變數包含NA值。

```{r NA, fig.height = 10, fig.width = 14}
na_col <- 
  all[is.na(all) %>% colSums %>% ">"(0) %>% which] %>% 
  sapply(is.na) %>% 
  colSums() %>% 
  sort(decreasing = TRUE) 
na_col
```

我將會在後面特徵工程時連同重新編碼、轉換變數時一併處理NA值。

# 特徵工程
## 資料清洗
### 疑漏值處理

我會在這邊進行遺漏值NA的處理，也會連帶處理跟具有NA變數相關的變數群。

#### Pool
```{r pool1}
na_col[names(na_col) %>% str_detect("Pool") %>% which]
```

##### PoolQC
2909個NA  
PoolQC: Pool quality

*  Ex   Excellent
*  Gd   Good
*  TA   Average/Typical
*  Fa   Fair
*  NA   No Pool


```{r poolQC}
all$PoolQC[is.na(all$PoolQC)] <- 'None'
all$PoolQC<-as.integer(plyr::revalue(all$PoolQC,
                                     c('None' = 0, 'Po' = 1, 
                                       'Fa' = 2, 'TA' = 3,
                                       'Gd' = 4, 'Ex' = 5)))
table(all$PoolQC)
all[all$PoolQC != 0,c("SalePrice","PoolQC","PoolArea","OverallQual")]

all %>% 
  filter(!(is.na(SalePrice)) & PoolQC != 0) %>% 
  ggplot(aes(x = PoolArea, 
             y = SalePrice ,
             size = PoolQC
             )) +
  geom_point(color = "steelblue") +
               GGvisualize_theme()

```

有游泳池的房子只有10間，圖形上顯示Pool相關變數似乎不那麼顯著影響房價。後面特徵工程的時候我或許會把這類別變數轉成是否有游泳池就好，評級可能不太需要。在這邊我先把NA值轉成NO，並且把它轉成類別變數。

##### PoolArea
另一個跟Pool有關的是PoolArea:

```{r PoolArea}
table(all$PoolArea != 0 )
```

竟然有13個值(PoolQC只有10個)。

```{r PoolArea2}
all[all$PoolArea>0 & all$PoolQC == 0, c('SalePrice','PoolArea', 'PoolQC', 'OverallQual')]
```

這三個疑似缺漏值的資料出現在要預測的資料集裡面，我們也不能隨便亂刪掉，只好透過觀察現有的10筆資料來填補PoolQC回去。

```{r PoolArea3}
all[all$PoolArea > 0,] %>% 
  ggplot(aes(x = OverallQual,y = PoolArea)) + 
  geom_point(aes(alpha = PoolQC),
             size = 10,color = 'steelblue') +
  geom_text(aes(label = ifelse(all[all$PoolArea > 0,"PoolArea"]> 0,
                               rownames(all[all$PoolArea > 0,]),
                               "")),nudge_y = 40)  +
  GGvisualize_theme()
```


透過上圖我會把這三個值都填2回去比較合理。

```{r PoolArea4}
all$PoolQC[c(2421,2504,2600)] <- 2

all[all$PoolArea > 0,] %>% 
  ggplot(aes(x = OverallQual,y = PoolArea)) + 
  geom_point(aes(alpha = PoolQC),
             size = 10,color = 'steelblue') +
  geom_text(aes(label = ifelse(all[all$PoolArea > 0,"PoolArea"]> 0,
                               rownames(all[all$PoolArea > 0,]),
                               "")),nudge_y = 25)  +
  GGvisualize_theme()

```


#### Miscellaneous Feature
```{r Miscellaneous Feature}
names(all)[names(all) %>% str_detect("Mis") %>% which]
na_col[names(na_col) %>% str_detect("Mis") %>% which]
```

2814個NA
MiscFeature: Miscellaneous feature not covered in other categories

* Elev Elevator
* Gar2 2nd Garage (if not described in garage section)
* Othr Other
* Shed Shed (over 100 SF)
* TenC Tennis Court
* NA   None 

轉成factor。

```{r MiscFeature}
all$MiscFeature[is.na(all$MiscFeature)] <- "None"
all$MiscFeature <- as.factor(all$MiscFeature)
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot(aes(x=MiscFeature, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma) +
  geom_label(stat = "count", aes(label = ..count.., y = ..count..)) +
  GGvisualize_theme() +
  annotate('text',x = 2.4,y = 245000,label = '總共')+
  annotation_custom(tableGrob(table(all$MiscFeature) %>% as.data.frame()%>% t ,
                              rows = NULL), 
                    xmin=0.75, xmax=4, 
                    ymin=180000, ymax=250000)

```


看起來MiscFeature這類別變數沒甚麼相關，絕大多數都是None居多。第二多的shed也沒有明顯和None有差異，差異比較大的TenC和Othr佔的件數又少很多。

##### MiscVal
驗證一下是否有MiscVal有值而MiscFeature是None，或是MiscVal為0而MiscFeature不是None的情況發生。
```{r MiscVal}
all %>% 
  filter(!(MiscFeature %in% "None") & MiscVal == 0) %>%
  select("Id","MiscVal","MiscFeature","SalePrice")
all %>% 
  filter(MiscFeature %in% "None" & MiscVal != 0) %>%
  select("Id","MiscVal","MiscFeature","SalePrice")

```


這三筆資料我不會去更動它，因為我並不知道價值為0是因為誤植還是它真的就是免費大贈送的。至於2550這筆就奇怪了，MiscFeature為None但是MiscVal卻高達17000，觀察一下MiscVal和MiscFeature的交叉分布。

```{r MiscVal1}
all %>% 
  filter(!(is.na(SalePrice)),MiscVal != 0) %>% 
  ggplot(aes(x = SalePrice,y = MiscVal,color = MiscFeature)) +
  geom_point(size = 3) + 
  GGvisualize_theme()

```
根據圖形我會將2550的MiscFeature改為Gar2

```{r MiscVal2}
all[2550,'MiscFeature'] <- 'Gar2'
```



#### Alley
2721個NA
Alley: Type of alley access to property

* Grvl Gravel
* Pave Paved
* NA   No alley access

轉成factor。

```{r Alley}
all$Alley[is.na(all$Alley)] <- 'None'
all$Alley %<>% as.factor()
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot(aes(x=Alley, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2')+
  scale_y_continuous(breaks= seq(0, 200000, by=50000), labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme() +
  annotate('text',x = 0.9 ,y = 175000  ,label = '總共')+
  annotation_custom(tableGrob(table(all$Alley) %>% as.data.frame() ,
                              rows = NULL,cols = NULL), 
                    xmin=0.25, xmax = 1.5, 
                    ymin=120000, ymax=175000)
```

#### Fence
2348個NA
Fence: Fence quality

* GdPrv    Good Privacy
* MnPrv    Minimum Privacy
* GdWo Good Wood
* MnWw Minimum Wood/Wire
* NA   No Fence

```{r Fence}
all$Fence[is.na(all$Fence)] <- 'None'
all %>% 
  filter(!(is.na(SalePrice))) %>%
  ggplot(aes(x=Fence, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2')+
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme() +
  annotate('text',x = 3 ,y = 60000  ,label = '總共')+
  annotation_custom(tableGrob(table(all$Fence) %>% as.data.frame() %>% t() ,rows = NULL), 
                    xmin=1.5, xmax = 4.5, 
                    ymin=5000, ymax=75000)
all$Fence <- as.factor(all$Fence)

```

看起來沒有明顯的次序關係，沒有Fence的房屋價格比較高，所以轉成factor。

#### Fireplace
```{r Fireplace}
names(all)[names(all) %>% str_detect("Fireplace") %>% which]
na_col[names(na_col) %>% str_detect("Fireplace") %>% which]
```

##### FireplaceQu
1420個NA
* Ex   Excellent - Exceptional Masonry Fireplace
* Gd   Good - Masonry Fireplace in main level
* TA   Average - Prefabricated Fireplace in main living area or Masonry  Fireplace in basement  
* Fa   Fair - Prefabricated Fireplace in basement
* Po   Poor - Ben Franklin Stove
* NA   No Fireplace

像這種在變數說明或者常理上能夠認知是有次序的，我都會把他轉成數值。

```{r FireplaceQu}
all$FireplaceQu[is.na(all$FireplaceQu)] <- 'None'
all$FireplaceQu<-as.integer(plyr::revalue(all$FireplaceQu,
                                          c('None' = 0, 'Po' = 1, 
                                            'Fa' = 2, 'TA' = 3,
                                            'Gd' = 4, 'Ex' = 5)))
all %>% 
  filter(!(is.na(SalePrice))) %>%
  ggplot(aes(x = FireplaceQu, y = SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2')+
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme() +
  annotate('text',x = 2 ,y = 290000  ,label = '總共')+
  annotation_custom(tableGrob(table(all$FireplaceQu) %>% as.data.frame() %>% t() ,
                              rows = NULL), 
                    xmin=0, xmax = 4, 
                    ymin=220000, ymax=280000)
```

##### Fireplaces

```{r Fireplaces}
table(all$Fireplaces)
all %>% 
  filter(!(is.na(SalePrice))) %>%
  ggplot(aes(x = Fireplaces, y = SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2')+
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()
```


#### Lot

```{r Lot}
names(all)[names(all) %>% str_detect("Lot") %>% which]
na_col[names(na_col) %>% str_detect("Lot") %>% which]
```

##### LotFrontage
LotFrontage: Linear feet of street connected to property
486個NA
初步建模我先根據房屋所在地區的中位數來填補。為什麼呢？拿台灣來說吧，嘉義縣的房子大部分來說要到街上肯定比台北市的房子去到街上還要遠，這就是郊區跟市區的差別。但是這樣還是會有偏誤，以台北市來說北投區內湖區有可能會比中正區信義區還要來的遠，也就是說城市內部也會存在著很大的差異。下一次我有可能會針對這個變數單獨建一個模型來估計它的遺漏值。

```{r LotFrontage_plot,fig.height = 10, fig.width = 14,warning=F}
all %>% 
  ggplot( aes(x=as.factor(Neighborhood), y=LotFrontage)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='black',width = 0.5) + 
  GGvisualize_theme()
```

藍色是中位數，黑色是標準差。從圖上可以看出部分城鎮跟城鎮以及區域跟區域之間存在著上述所講的差異。

```{r LotFrontage}
#利用dplyr結合ifelse進行向量式填補
all %<>% 
  group_by(Neighborhood) %>% 
  mutate(LotFrontage = ifelse(is.na(LotFrontage),
                              median(LotFrontage,na.rm = T),
                              LotFrontage)) %>% 
  as.data.frame()
```


##### LotShape
沒有NA

* Reg  Regular 
* IR1  Slightly irregular
* IR2  Moderately Irregular
* IR3  Irregular

看起來應該是有次序的變數，但是視覺化後卻不是這樣。

```{r LotShape}
table(all$LotShape)
#將其轉換為數字
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=LotShape, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..))+ 
  GGvisualize_theme()
#轉為factor
all$LotShape %<>% as.factor()

```


##### LotConfig
沒有NA

* Inside   Inside lot
* Corner   Corner lot
* CulDSac  Cul-de-sac
* FR2  Frontage on 2 sides of property
* FR3  Frontage on 3 sides of property

應該不是有次序的變數，把它轉成factor。

```{r LotConfig}
all$LotConfig %<>% as.factor()
table(all$LotConfig)

```


#### Garage

```{r Garage}
names(all)[names(all) %>% str_detect("Garage") %>% which]
na_col[names(na_col) %>% str_detect("Garage") %>% which]
```

##### GarageYrBlt

GarageYrBlt: Year garage was built 

這邊我會將車庫建造年的NA值改成YearBuilt的年份,NA值有可能是因為該房子沒有車庫,改成YearBuilt的理由類似YearRemodAdd.在說明文件裡面YearRemodAdd: Remodel date (same as construction date if no remodeling or additions).

```{r GarageYrBlt}
all$GarageYrBlt[is.na(all$GarageYrBlt)] <- all$YearBuilt[is.na(all$GarageYrBlt)]

```


##### GarageCars & GarageArea

```{r GarageCars & GarageArea}
all[!is.na(all$GarageType) & is.na(all$GarageFinish),
    c('GarageCars', 'GarageArea', 'GarageType',
      'GarageCond', 'GarageQual', 'GarageFinish')]
```

看起來2127似乎是有車庫,2577沒有,那就把2577改成沒有車庫,2127的GarageCond	GarageQual	GarageFinish的三個NA值改成該變數最多的值

```{r }
all$GarageCond[2127] <- names(sort(-table(all$GarageCond)))[1]
all$GarageQual[2127] <- names(sort(-table(all$GarageQual)))[1]
all$GarageFinish[2127] <- names(sort(-table(all$GarageFinish)))[1]
all[2127,
    c('GarageYrBlt', 'GarageCars', 'GarageArea',
      'GarageType', 'GarageCond', 'GarageQual', 'GarageFinish')]
#修改2577
all$GarageCars[2577] <- 0
all$GarageArea[2577] <- 0
all$GarageType[2577] <- NA

#這樣就讓剩下Garage NA一致了
all[,str_detect(names(all),"Garage")] %>% 
  sapply(is.na) %>% 
  colSums() %>% 
  "["(.!=0)
```

##### GarageType

* 2Types   More than one type of garage
* Attchd   Attached to home
* Basment  Basement Garage
* BuiltIn  Built-In (Garage part of house - typically has room above garage)
* CarPort  Car Port
* Detchd   Detached from home
* NA   No Garage

```{r GarageType}
all$GarageType[is.na(all$GarageType)] <- 'No Garage'
all$GarageType <- as.factor(all$GarageType)
table(all$GarageType)
```

##### GarageFinish

* Fin  Finished
* RFn  Rough Finished  
* Unf  Unfinished
* NA   No Garage

```{r GarageFinish}
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=GarageFinish, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()

all$GarageFinish[is.na(all$GarageFinish)] <- 'None'
all$GarageFinish <- as.integer(plyr::revalue(all$GarageFinish,
                                             c('None'=0, 'Unf'=1, 
                                               'RFn'=2, 'Fin'=3)))
table(all$GarageFinish)
```

暗紅色代表標準差，明顯的次序關係我就將其轉成數字。

##### GarageQual

* Ex   Excellent
* Gd   Good
* TA   Typical/Average
* Fa   Fair
* Po   Poor
* NA   No Garage

```{r GarageQual}
all$GarageQual[is.na(all$GarageQual)] <- 'None'
all$GarageQual <-
  as.integer(plyr::revalue(all$GarageQual, c('None' = 0, 'Po' = 1, 'Fa' = 2,
                                             'TA' = 3,'Gd' = 4, 'Ex' = 5)))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=GarageQual, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_x_continuous(breaks = seq(min(all$GarageQual),max(all$GarageQual))) + 
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()
```

從圖形上可以看出Poor Garge 幾乎跟沒有Garge一樣，感覺沒有Garge可能還比較好。另外Ex Garage數量稀少所以標準差還比中位數大，可見三個物件彼此相異很大。這邊我會把0和1以及4和5合併增加這個變數的可解釋性。

```{r GarageQual2}
all$GarageQual <- ifelse(all$GarageQual %in% c(0:1),0,
                         ifelse(all$GarageQual %in% c(4:5),3,all$GarageQual - 1))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=GarageQual, y=SalePrice)) +
  geom_bar(stat = 'summary', fun = "median", fill = 'dodgerblue2') +
  geom_bar(stat = 'summary', fun = "sd", fill = 'deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..))  + 
  GGvisualize_theme()
```


##### GarageCond

* Ex   Excellent
* Gd   Good
* TA   Typical/Average
* Fa   Fair
* Po   Poor
* NA   No Garage

```{r GarageCond}
all$GarageCond[is.na(all$GarageCond)] <- 'None'
all$GarageCond <-
  as.integer(plyr::revalue(all$GarageCond, 
                           c('None' = 0, 'Po' = 1, 'Fa' = 2,
                             'TA' = 3,'Gd' = 4, 'Ex' = 5)))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=GarageCond, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_x_continuous(breaks = seq(min(all$GarageCond),max(all$GarageCond))) + 
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..))  + 
  GGvisualize_theme()
```


#### Basement

```{r Basement}
na_col[names(na_col) %>% str_detect("Bsmt") %>% which]

```
總共有11個變數和basement有關,其中有六個變數是只有1-2個NA,5個是79-82,先來統計一下這5個變數都是NA的資料筆數有幾個

```{r Basement2}
length(which(is.na(all$BsmtQual) & is.na(all$BsmtCond) & 
             is.na(all$BsmtExposure) & is.na(all$BsmtFinType1) & 
             is.na(all$BsmtFinType2)))
```

可見會有BsmtFinType1不是NA,而其他四個變數則有NA得情況,我得找出這種情況才行


```{r Basement3}
all[!is.na(all$BsmtFinType1) & 
      (is.na(all$BsmtCond)|
       is.na(all$BsmtQual)|
       is.na(all$BsmtExposure)|
       is.na(all$BsmtFinType2)),
    c('BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2')]
```

這邊的遺漏值我就用眾數來填補.

```{r Basement4}
all$BsmtFinType2[333] <- names(sort(-table(all$BsmtFinType2)))[1]
all$BsmtExposure[c(949, 1488, 2349)] <- names(sort(-table(all$BsmtExposure)))[1]
all$BsmtCond[c(2041, 2186, 2525)] <- names(sort(-table(all$BsmtCond)))[1]
all$BsmtQual[c(2218, 2219)] <- names(sort(-table(all$BsmtQual)))[1]

```


##### BsmtQual

* Ex   Excellent (100+ inches) 
* Gd   Good (90-99 inches)
* TA   Typical (80-89 inches)
* Fa   Fair (70-79 inches)
* Po   Poor (&lt;70 inches
* NA   No Basement

```{r BsmtQual}
all$BsmtQual[is.na(all$BsmtQual)] <- 'None'
table(all$BsmtQual)
all$BsmtQual <-
  as.integer(plyr::revalue(all$BsmtQual, 
             c('None' = 0, 'Fa' = 1,
               'TA' = 2,'Gd' = 3, 'Ex' = 4)))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=BsmtQual, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..))  + 
  GGvisualize_theme()
```


##### BsmtCond

* Ex   Excellent
* Gd   Good
* TA   Typical - slight dampness allowed
* Fa   Fair - dampness or some cracking or settling
* Po   Poor - Severe cracking, settling, or wetness
* NA   No Basement

```{r BsmtCond}
all$BsmtCond[is.na(all$BsmtCond)] <- 'None'
table(all$BsmtCond)
all$BsmtCond <-
  as.integer(plyr::revalue(all$BsmtCond, c('None' = 0, 'Po' = 1, 'Fa' = 2,
                                           'TA' = 3,'Gd' = 4)))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=BsmtCond, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..))  + 
  GGvisualize_theme()

```


##### BsmtExposure

* Gd   Good Exposure
* Av   Average Exposure (split levels or foyers typically score average or above)  
* Mn   Mimimum Exposure
* No   No Exposure
* NA   No Basement
   
```{r BsmtExposure}
all$BsmtExposure[is.na(all$BsmtExposure)] <- 'None'
all$BsmtExposure <-
  as.integer(plyr::revalue(all$BsmtExposure, 
                           c('None'=0, 'No'=1, 'Mn'=2,
                             'Av'=3, 'Gd'=4)))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=BsmtExposure, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..))  + 
  GGvisualize_theme()
```


##### BsmtFinType1

* GLQ  Good Living Quarters
* ALQ  Average Living Quarters
* BLQ  Below Average Living Quarters   
* Rec  Average Rec Room
* LwQ  Low Quality
* Unf  Unfinshed
* NA   No Basement

```{r BsmtFinType1}
all$BsmtFinType1[is.na(all$BsmtFinType1)] <- 'None'
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=factor(BsmtFinType1,levels =c('None', 'Unf', 'LwQ',
                                              'Rec', 'BLQ', 'ALQ','GLQ')),
              y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  xlab('BsmtFinType1') +
  geom_label(stat = "count",aes(label = ..count..,y = ..count..))  + 
  GGvisualize_theme()
```

看起來 'LwQ','Rec', 'BLQ', 'ALQ'似乎在售價上面沒甚麼差別，反而Unf還能賣高一點，但是其標準差有點高代表不見得Unf每個物件都能賣高一點。在這邊我會把'LwQ','Rec', 'BLQ', 'ALQ'合併成一個'ABRL'並將這個變數轉為factor。

```{r BsmtFinType1_2}
all$BsmtFinType1 <- ifelse(all$BsmtFinType1 %in% c('LwQ','Rec', 'BLQ', 'ALQ'),
                           'ABRL',all$BsmtFinType1)
all$BsmtFinType1 %<>% factor(levels = c('None','Unf','ABRL','GLQ'))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=BsmtFinType1,
              y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..))  + 
  GGvisualize_theme()
```
##### BsmtFinType2

* GLQ  Good Living Quarters
* ALQ  Average Living Quarters
* BLQ  Below Average Living Quarters   
* Rec  Average Rec Room
* LwQ  Low Quality
* Unf  Unfinshed
* NA   No Basement

```{r BsmtFinType2}
all$BsmtFinType2[is.na(all$BsmtFinType2)] <- 'None'

all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=factor(BsmtFinType2,levels =c('None', 'Unf', 'LwQ',
                                              'Rec', 'BLQ', 'ALQ','GLQ')),
              y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  xlab('BsmtFinType2') +
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()

```

情況跟BsmtFinType1類似，但是ALQ似乎有比較跟'LwQ','Rec'和'BLQ'有明顯的差距，可是其標準差高數量又偏少，感覺組內不夠一致。這邊還是會跟BsmtFinType1處理方法依樣，把'LwQ','Rec', 'BLQ', 'ALQ'合併成一個'ABRL'並將這個變數轉為factor。

```{r BsmtFinType2_2}
all$BsmtFinType2 <- 
  ifelse(all$BsmtFinType2 %in% c('LwQ','Rec', 'BLQ', 'ALQ'),
         'ABRL',all$BsmtFinType2)
all$BsmtFinType2 %<>% factor(levels = c('None','Unf','ABRL','GLQ'))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=BsmtFinType2,
              y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()
```


##### 剩餘的Basement

觀察剩下的Basement變數,顯然都不是含有地下室

```{r rest Basement}
all[(is.na(all$BsmtFullBath) | 
       is.na(all$BsmtHalfBath) |
       is.na(all$BsmtFinSF1) | is.na(all$BsmtFinSF2)|
       is.na(all$BsmtUnfSF) | is.na(all$TotalBsmtSF)),
    c('BsmtQual', 'BsmtFullBath', 'BsmtHalfBath', 'BsmtFinSF1',
      'BsmtFinSF2', 'BsmtUnfSF', 'TotalBsmtSF')]

all$BsmtFullBath[is.na(all$BsmtFullBath)] <-0
all$BsmtHalfBath[is.na(all$BsmtHalfBath)] <-0
all$BsmtFinSF1[is.na(all$BsmtFinSF1)] <-0
all$BsmtFinSF2[is.na(all$BsmtFinSF2)] <-0
all$BsmtUnfSF[is.na(all$BsmtUnfSF)] <-0
all$TotalBsmtSF[is.na(all$TotalBsmtSF)] <-0

```


#### Masonry

```{r Masonry}
na_col[names(na_col) %>% str_detect("MasVnr") %>% which]

```

通常房子有 veneer area,應該也會有 masonry veneer type，來確認一下是不是area 和type的NA都是互相存在在同一筆。

```{r Masonry1}
length(which(is.na(all$MasVnrType) & is.na(all$MasVnrArea)))
```

兩者的NA幾乎都出現在同一筆資料，也就是說type多一筆NA，我就用眾數來填補;但是2611列AREA有值，最多的因子是none,所以用第二多的來填補。


```{r Masonry2}

all[is.na(all$MasVnrType) & !is.na(all$MasVnrArea), c('MasVnrType', 'MasVnrArea')]
all$MasVnrType[2611] <- names(sort(-table(all$MasVnrType)))[2]

```

##### MasVnrType

* BrkCmn   Brick Common
* BrkFace  Brick Face
* CBlock   Cinder Block
* None None
* Stone    Stone

```{r MasVnrType,warning=F,message=F}
all$MasVnrType[is.na(all$MasVnrType)] <- 'None'

grid.arrange(
  ggplot(all, aes(x=MasVnrType, y=SalePrice)) +
    stat_summary(geom ='bar', fun = "median", fill='grey')+
    scale_y_continuous(labels = comma) + 
    geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
    GGvisualize_theme() + 
    ggtitle("Median"),
  ggplot(all, aes(x=MasVnrType, y=SalePrice)) +
    stat_summary(geom ='bar', fun = "mean", fill='black')+
    scale_y_continuous(labels = comma) + 
    geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
    GGvisualize_theme() + 
    ggtitle("Mean"),
  nrow = 2 ,ncol = 1
)
```

從平均和中位數來看,Brick Common和None似乎在銷售價格上很接近,這邊假設普通石造牆壁和木製一樣便宜,
那這樣我們就把BrkCmn和None合併起來,就能把MasVnrType變數弄成次序的。

```{r MasVnrType1}
all$MasVnrType<-as.integer(plyr::revalue(all$MasVnrType, 
                                         c('None'=0, 'BrkCmn'=0,
                                           'BrkFace'=1, 'Stone'=2)))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=MasVnrType, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()
```

##### MasVnrArea

```{r MasVnrArea}
all$MasVnrArea[is.na(all$MasVnrArea)] <- 0
```


#### MSZoning

* A    Agriculture
* C    Commercial
* FV   Floating Village Residential
* I    Industrial
* RH   Residential High Density
* RL   Residential Low Density
* RP   Residential Low Density Park 
* RM   Residential Medium Density

因為這個變數是土地的分區，有商業區農業區工業區等等,我覺得應該跟Neighborhood有關連。

```{r MSZoning1}
all %>% 
  group_by(MSZoning,Neighborhood) %>% 
  summarise(value = n()) %>% 
  xtabs(data = .,value~.) %>% 
  kable() %>% 
  scroll_box(width = '100%')
```

由上表可以看出Neighborhood和MSZoning的關聯性，有些地區主要是商業區例如IDOTRR然後搭配中密度的住宅，大概就像我們的信義區，剩下大部分都是住宅。所以後面會用和Neighborhood有關的方式填補回NA。

```{r MSZoning2}
all[all$MSZoning %>% is.na(),c('SalePrice','MSZoning', 'Neighborhood',"OverallQual")] 
```


4個NA有三個是IDOTRR區一個是Mitchel區。

```{r MSZoning3}

#IDOTRR
filter(all,Neighborhood == "IDOTRR",OverallQual<=5)$MSZoning %>% table
#Mitchel
filter(all,Neighborhood == "Mitchel",OverallQual<=5)$MSZoning %>% table
```

2905將用RL填補，1916 2217 2251因為IDOTRR可能為商業區遺失的資料三筆OverallQual差距有點大，下面我視覺化IDOTRR的SalePrice、MSZoning和OverallQual。


```{r MSZoning4,warning=F}
all %>% 
  filter(Neighborhood == 'IDOTRR') %>% 
  ggplot(aes(x = OverallQual,y = SalePrice,color = MSZoning)) +
  geom_point(size = 3) + 
  GGvisualize_theme()
```
1916 2217 因為OverallQual比較低我會填補C(all)回去，2251則填補RM回去。

```{r MSZoning5}
all[c(2251),"MSZoning"] <- "RM"
all[c(1916,2217),"MSZoning"] <- "C (all)"
all[2905,"MSZoning"] <- "RL"
all$MSZoning %<>% as.factor()
```

#### Kitchen

```{r Kitchen}
names(all)[names(all) %>% str_detect("Kitchen") %>% which]
na_col[names(na_col) %>% str_detect("Kitchen") %>% which]
```

##### KitchenQual

* Ex   Excellent
* Gd   Good
* TA   Typical/Average
* Fa   Fair
* Po   Poor

```{r KitchenQual}
table(all$KitchenQual)
all$KitchenQual[is.na(all$KitchenQual)] <- 'TA' #將最多的填補回去
all$KitchenQual<-as.integer(plyr::revalue(all$KitchenQual, 
                                          c('None' = 0, 'Po' = 1, 'Fa' = 2,
                                            'TA' = 3,'Gd' = 4, 'Ex' = 5)))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=KitchenQual, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()
```

#### Utilities

```{r Utilities}
table(all$Utilities)
```

變數因子嚴重不平衡,這變數對預測沒甚麼幫助,所以就剔除掉

```{r Utilities2}
all$Utilities <- NULL
```

#### Functional

* Typ  Typical Functionality
* Min1 Minor Deductions 1
* Min2 Minor Deductions 2
* Mod  Moderate Deductions
* Maj1 Major Deductions 1
* Maj2 Major Deductions 2
* Sev  Severely Damaged
* Sal  Salvage only

```{r Functional,warning=F}
na_col[names(na_col) %>% str_detect("Functional") %>% which]
table(all$Functional)
#眾數填補
all$Functional[is.na(all$Functional)] <- names(sort(-table(all$Functional)))[1]
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=factor(Functional,
                       levels =  c('Sal','Sev',
                                   'Maj2','Maj1',
                                   'Mod','Min2',
                                   'Min1','Typ')), 
              y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  xlab('Functional') + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()
```

看起來沒辦法轉成次序，且Min1&Min2看起來沒甚麼差，Maj1和Mod看起來也沒甚麼差但是Mod組內標準差太高了我不敢將它跟Maj1合併，這個變數就把Min1&Min2合併成Min然後轉成factor吧。


```{r Functional2}
all$Functional <- 
  ifelse(all$Functional %in% c('Min2','Min1'),
         'Min',all$Functional)
all$Functional %<>% as.factor()
```
#### Exter

```{r Exter}
names(all)[names(all) %>% str_detect("Exter") %>% which]
na_col[names(na_col) %>% str_detect("Exterior") %>% which]
```

##### Exterior1st

* AsbShng  Asbestos Shingles
* AsphShn  Asphalt Shingles
* BrkComm  Brick Common
* BrkFace  Brick Face
* CBlock   Cinder Block
* CemntBd  Cement Board
* HdBoard  Hard Board
* ImStucc  Imitation Stucco
* MetalSd  Metal Siding
* Other    Other
* Plywood  Plywood
* PreCast  PreCast 
* Stone    Stone
* Stucco   Stucco
* VinylSd  Vinyl Siding
* Wd Sdng  Wood Siding
* WdShing  Wood Shingles

```{r Exterior1st}
#眾數填補
all$Exterior1st[is.na(all$Exterior1st)] <- names(sort(-table(all$Exterior1st)))[1]
all$Exterior1st <- as.factor(all$Exterior1st)
table(all$Exterior1st)
```

##### Exterior2nd

同Exterior1st

```{r Exterior2nd}
all$Exterior2nd[is.na(all$Exterior2nd)] <- names(sort(-table(all$Exterior2nd)))[1]
all$Exterior2nd <- as.factor(all$Exterior2nd)
table(all$Exterior2nd)
```



##### ExterQual

* Ex   Excellent
* Gd   Good
* TA   Average/Typical
* Fa   Fair
* Po   Poor

```{r ExterQual,warning=F}
all$ExterQual <- as.integer(plyr::revalue(all$ExterQual,
                            c('None' = 0, 'Po' = 1, 'Fa' = 2,
                              'TA' = 3,'Gd' = 4, 'Ex' = 5)))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=ExterQual, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()

```


##### ExterCond

* Ex   Excellent
* Gd   Good
* TA   Average/Typical
* Fa   Fair
* Po   Poor

```{r ExterCond,warning=F}
all$ExterCond <- 
  as.integer(plyr::revalue(all$ExterCond,
             c('None' = 0, 'Po' = 1, 'Fa' = 2,
               'TA' = 3,'Gd' = 4, 'Ex' = 5)))

all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=ExterCond, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()

```


##### Electrical

* SBrkr    Standard Circuit Breakers & Romex
* FuseA    Fuse Box over 60 AMP and all Romex wiring (Average) 
* FuseF    60 AMP Fuse Box and mostly Romex wiring (Fair)
* FuseP    60 AMP Fuse Box and mostly knob & tube wiring (poor)
* Mix  Mixed

```{r Electrical}
names(all)[names(all) %>% str_detect("Elect") %>% which]
na_col[names(na_col) %>% str_detect("Elect") %>% which]
#眾數填補
all$Electrical[is.na(all$Electrical)] <- names(sort(-table(all$Electrical)))[1]
all$Electrical <- as.factor(all$Electrical)
table(all$Electrical)

```


#### Sale Type and Condition

```{r Sale Type and Condition}
names(all)[names(all) %>% str_detect("Sale") %>% which][-1]
na_col[names(na_col) %>% str_detect("Sale") %>% which][-1]
```

##### SaleType

```{r SaleType}
#眾數填補
all$SaleType[is.na(all$SaleType)] <- names(sort(-table(all$SaleType)))[1]
all$SaleType <- as.factor(all$SaleType)
table(all$SaleType)
```

##### SaleCondition

* Normal   Normal Sale
* Abnorml  Abnormal Sale -  trade, foreclosure, short sale
* AdjLand  Adjoining Land Purchase
* Alloca   Allocation - two linked properties with separate deeds, typically condo with a garage unit  
* Family   Sale between family members
* Partial  Home was not completed when last assessed (associated with New Homes) number of bedrooms

```{r SaleCondition}
all$SaleCondition <- as.factor(all$SaleCondition)
table(all$SaleCondition)
```


### 剩餘字串變數

```{r charcol}
charcol <- names(all[,sapply(all, is.character)])
charcol
```

#### Foundation

* BrkTil Brick & Tile
* CBlock Cinder Block
* PConc Poured Contrete 
* Slab Slab
* Stone Stone
* Wood Wood

```{r Foundation}
all$Foundation <- as.factor(all$Foundation)
table(all$Foundation)
```

#### Heating and air condition

```{r Heating and air condition}
names(all)[names(all) %>% str_detect("Heating") %>% which]
```

##### Heating

* Floor Floor Furnace
* GasA Gas forced warm air furnace
* GasW Gas hot water or steam heat
* Grav Gravity furnace 
* OthW Hot water or steam heat other than gas
* Wall Wall furnace

```{r Heating}
all$Heating <- as.factor(all$Heating)
table(all$Heating)
```

##### HeatingQC

* Ex   Excellent
* Gd   Good
* TA   Average/Typical
* Fa   Fair
* Po   Poor

```{r HeatingQC, message=FALSE, warning=FALSE}
all$HeatingQC <- 
  as.integer(plyr::revalue(all$HeatingQC, 
             c('None' = 0, 'Po' = 1, 'Fa' = 2,
               'TA' = 3,'Gd' = 4, 'Ex' = 5)))

all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=HeatingQC, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()

```

##### CentralAir

* N    No
* Y    Yes

布林值，直接把他轉成1和0

```{r CentralAir}
all$CentralAir <- 
  as.integer(plyr::revalue(all$CentralAir, 
             c('N'=0, 'Y'=1)))
table(all$CentralAir)
```


#### Roof

```{r Roof}
names(all)[names(all) %>% str_detect("Roof") %>% which]
```


##### RoofStyle

* Flat Flat
* Gable Gable
* Gambrel Gabrel (Barn)
* Hip Hip
* Mansard Mansard
* Shed Shed

```{r RoofStyle}
all$RoofStyle <- as.factor(all$RoofStyle)
table(all$RoofStyle)
```

##### RoofMatl

* ClyTile  Clay or Tile
* CompShg  Standard (Composite) Shingle
* Membran  Membrane
* Metal    Metal
* Roll Roll
* Tar&Grv  Gravel & Tar
* WdShake  Wood Shakes
* WdShngl  Wood Shingles

```{r RoofMatl}
all$RoofMatl <- as.factor(all$RoofMatl)
table(all$RoofMatl)
```

#### Land

```{r Land}
names(all)[names(all) %>% str_detect("Land") %>% which]
```

##### LandContour

* Lvl  Near Flat/Level 
* Bnk  Banked - Quick and significant rise from street grade to building
* HLS  Hillside - Significant slope from side to side
* Low  Depression

```{r LandContour}
all$LandContour <- as.factor(all$LandContour)
table(all$LandContour)
```

##### LandSlope

* Gtl  Gentle slope
* Mod  Moderate Slope  
* Sev  Severe Slope

```{r LandSlope}
table(all$LandSlope)
all$LandSlope <- 
  as.integer(plyr::revalue(all$LandSlope, 
             c('Sev' = 0, 'Mod' = 1, 'Gtl' = 2)))

all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=LandSlope, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()

```

將Landslope轉換為次序之後並將其視覺化，可以發現銷售價格似乎並沒有隨著傾斜程度而變動，我就將其改回類別變數吧

```{r LandSlope1}
all$LandSlope %<>% as.factor()
```


#### 住宅相關變數

##### BldgType

* 1Fam Single-family Detached  
* 2FmCon Two-family Conversion; originally built as one-family dwelling
* Duplx Duplex
* TwnhsE Townhouse End Unit
* TwnhsI Townhouse Inside Unit  
註:TwnhsI 在資料裡面少了個I

```{r BldgType}
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=as.factor(BldgType), y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()
```


沒有次序關係，轉成類別變數吧


```{r BldgType2}
all$BldgType <- as.factor(all$BldgType)
```



##### HouseStyle 

* 1Story   One story
* 1.5Fin   One and one-half story: 2nd level finished
* 1.5Unf   One and one-half story: 2nd level unfinished
* 2Story   Two story
* 2.5Fin   Two and one-half story: 2nd level finished
* 2.5Unf   Two and one-half story: 2nd level unfinished
* SFoyer   Split Foyer
* SLvl     Split Level

```{r HouseStyle}
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=HouseStyle, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()
#轉成factor
all$HouseStyle <- as.factor(all$HouseStyle)
```


#### Neighborhood 

```{r Neighborhood}
table(all$Neighborhood)
```


毫無懸念就是factor

```{r Neighborhood2}

all$Neighborhood <- as.factor(all$Neighborhood)
```

#### Condition

##### Condition1

* Artery   Adjacent to arterial street
* Feedr    Adjacent to feeder street   
* Norm Normal  
* RRNn Within 200' of North-South Railroad
* RRAn Adjacent to North-South Railroad
* PosN Near positive off-site feature--park, greenbelt, etc.
* PosA Adjacent to postive off-site feature
* RRNe Within 200' of East-West Railroad
* RRAe Adjacent to East-West Railroad

```{r Condition1}
table(all$Condition1)
all$Condition1 <- as.factor(all$Condition1)
```


##### Condition2

* Artery   Adjacent to arterial street
* Feedr    Adjacent to feeder street   
* Norm Normal  
* RRNn Within 200' of North-South Railroad
* RRAn Adjacent to North-South Railroad
* PosN Near positive off-site feature--park, greenbelt, etc.
* PosA Adjacent to postive off-site feature
* RRNe Within 200' of East-West Railroad
* RRAe Adjacent to East-West Railroad

```{r Condition2}
table(all$Condition2)
all$Condition2 <- as.factor(all$Condition2)
```


#### Street & PavedDrive

##### Street

Street: Type of road access to property

* Grvl Gravel  
* Pave Paved

```{r Street}
table(all$Street)
all$Street<-as.integer(plyr::revalue(all$Street, c('Grvl'=0, 'Pave'=1)))
```


##### PavedDrive

PavedDrive: Paved driveway

* Y    Paved 
* P    Partial Pavement
* N    Dirt/Gravel

我覺得可以轉成次序的

```{r PavedDrive}
table(all$PavedDrive)
all$PavedDrive<-as.integer(plyr::revalue(all$PavedDrive,
                                         c('N'=0, 'P'=1, 'Y'=2)))
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=PavedDrive, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()

```

### 數值變數轉成類別變數

#### MoSold&YrSold

這邊將月份和年份轉成類別變數的原因是房價銷售的價格並不會隨著月份或年份增加而增加亦或是減少，這樣很奇怪不太合理，圖形上也顯示不管是在月份還是年份沒有一定的趨勢，所以轉成factor。

```{r MoSold & YrSold}
all$MoSold <- as.factor(all$MoSold)
all$YrSold <- as.factor(all$YrSold)

grid.arrange(
  all %>% 
    filter(!(is.na(SalePrice))) %>% 
    ggplot(aes(x=as.factor(YrSold), y=SalePrice)) +
    stat_summary(geom ='bar', fun = "median", fill='dodgerblue2')+
    stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
    scale_y_continuous(breaks= seq(0, 800000, by=25000), labels = comma) +
    geom_label(stat = "count", aes(label = ..count.., y = ..count..)) +
    coord_cartesian(ylim = c(0, 200000)) +
    geom_hline(yintercept=163000, linetype="dashed", color = "red") + 
  GGvisualize_theme()
  , #dashed line is median SalePrice
  all %>% 
    filter(!(is.na(SalePrice))) %>% 
    ggplot( aes(x=MoSold, y=SalePrice)) +
    stat_summary(geom ='bar', fun = "median", fill='dodgerblue2')+
    stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
    scale_y_continuous(breaks= seq(0, 800000, by=25000), labels = comma) +
    geom_label(stat = "count", aes(label = ..count.., y = ..count..)) +
    coord_cartesian(ylim = c(0, 200000)) +
    geom_hline(yintercept=163000, linetype="dashed", color = "red") + 
    GGvisualize_theme() + 
    theme(axis.title.y = element_blank(),
          axis.text.y = element_blank())
  , #dashed line is median SalePrice
  widths=c(2,3)
  )
```


#### MSSubClass

MSSubClass: Identifies the type of dwelling involved in the sale.

* 20  1-STORY 1946 & NEWER ALL STYLES
* 30  1-STORY 1945 & OLDER
* 40  1-STORY W/FINISHED ATTIC ALL AGES
* 45  1-1/2 STORY - UNFINISHED ALL AGES
* 50  1-1/2 STORY FINISHED ALL AGES
* 60  2-STORY 1946 & NEWER
* 70  2-STORY 1945 & OLDER
* 75  2-1/2 STORY ALL AGES
* 80  SPLIT OR MULTI-LEVEL
* 85  SPLIT FOYER
* 90  DUPLEX - ALL STYLES AND AGES
* 120  1-STORY PUD (Planned Unit Development) - 1946 & NEWER
* 150  1-1/2 STORY PUD - ALL AGES
* 160  2-STORY PUD - 1946 & NEWER
* 180  PUD - MULTILEVEL - INCL SPLIT LEV/FOYER
* 190  2 FAMILY CONVERSION - ALL STYLES AND AGES

看起來應該就是直接轉factor了，數字基本上只是被用來區分銷售上的類別而已

```{r MSSubClass}
table(all$MSSubClass)
all$MSSubClass <- as.factor(all$MSSubClass)

```

###小結

檢視一下處理過後連續變數和類別變數數量。

```{r afterClean}
num_var2 <- which(sapply(all, is.numeric)) 
factor_var <- which(sapply(all, is.factor))
cat('總共有', length(num_var2), '連續變數, and',
    length(factor_var), '類別變數')
```

類別變數被我從43個減少到29個、數值變數則從38個增加到51個，比較有利於後續模型建模。

## 探索資料分析&特徵組合

### 相關性

由於前面資料清洗的部分已經先處理過資料一輪，下面再畫一次處理前和處理後數值變數相關性的圖來比較一下差異。這邊因為corrplot不是grob物件，沒辦法用grid.arrange，[stackoverflow](https://stackoverflow.com/questions/53734543/converting-corrplot-output-to-grob)這邊有解法能夠將corrplot轉成grob物件，但是我還是先用base套件來繪圖。

```{r CorplotAfter,warning=F,out.width='\\textwidth',fig.height=6,fig.width=12}
#相關性
CorNumvar_after <- cor(all[, num_var2], 
                  use="pairwise.complete.obs") 
CorSortName_after <- sort(CorNumvar_after[,'SalePrice'], 
                      decreasing = TRUE) %>% 
                     as.matrix() %>% 
                     apply(1, function(x) abs(x)>0.5) %>% 
                     which() %>% 
                     names()
CorNumvarSort <- CorNumvar_after[CorSortName_after, CorSortName_after]

oldpar <- par()
par(mfrow = c(1,2))
corrplot.mixed(cor_numvar_sort,
               tl.col="black",
               tl.pos = "lt",
               tl.cex = 0.7, #標題大小
               cl.cex = 0.7, #color bar 大小
               number.cex=0.7,
               title = 'BEROFE',
               mar=c(0,0,2,0))

corrplot.mixed(CorNumvarSort, 
               tl.col="black", 
               tl.pos = "lt", 
               tl.cex = 0.7, #標題大小
               cl.cex = 0.7, #color bar 大小
               number.cex=0.7,
               title = 'AFTER',
               mar=c(0,0,2,0))
par(oldpar)

```


### 重要性

<span style="color:red">隨機森林</span>有個很好用的功能就是它能幫你選出對預測有幫助的特徵。它的作法就是底層建一大堆樹，每一根樹都會隨機對資料抽n個樣本，對特徵隨機抽y個特徵。那為什麼說它能幫你挑選特徵呢，因為它能對預測效果好的樹count它所使用的特徵，最後再排序每個特徵被選取的次數來建立特徵的重要性。

```{r RandomForest,eval = FALSE}
set.seed(2018)
quick_RF <- randomForest(x=all %>% 
                            filter(!(is.na(SalePrice))) %>% 
                            select(-SalePrice,-Id),
                         
                         y=all %>% 
                            filter(!(is.na(SalePrice))) %>% 
                            "$"(SalePrice),
                         ntree=100,importance=TRUE)
imp_RF <- importance(quick_RF)
imp_DF <- data.frame(Variables = row.names(imp_RF),
                     MSE = imp_RF[,1]) %>% 
          arrange(desc(MSE))

important <- ggplot(imp_DF[1:30,], 
                    aes(x=reorder(Variables, MSE),
                        y=MSE, 
                        fill=MSE)) + 
             geom_bar(stat = 'identity') + 
             scale_y_continuous(labels = function(x)paste0(x,'%')) +
             labs(x = '變數', 
                  y= '替換掉MSE會提升的%數') + 
             coord_flip() + 
             GGvisualize_theme() +
             theme(legend.position="none",
                   axis.text.x = element_text(size = 25,
                                              face = 'bold'),
                   axis.text.y = element_text(size = 30,
                                              face = 'bold'),
                   axis.title.x = element_text(size = 30,
                                               face = 'bold'),
                   axis.title.y = element_text(size = 30,
                                               face = 'bold')) 
```


![](output/importance.png)

最重要的幾個變數GrLivArea、Neighborhood和OverallQual都超過10%，表示如過拿掉該變數誤差大約會提升10%以上。接下來幾個小節我會依照重要性排名前幾名做個簡單的EDA並且視覺化它們。

### 和GrLivArea相關特徵

```{r GrLivAreaEDA,warning=F}
grid.arrange(all %>% ggplot() +
               geom_density(aes(x = GrLivArea),
                            fill = 'pink',color = 'deeppink') + 
               scale_x_continuous(breaks = seq(0,6000,1000),limits = c(0,7000)) + 
               GGvisualize_theme(),
             all %>% ggplot() +
               geom_density(aes(x = X1stFlrSF),
                            fill = 'pink',color = 'deeppink') + 
               scale_x_continuous(breaks = seq(0,6000,1000),limits = c(0,7000)) + 
               GGvisualize_theme(),
             all %>% ggplot() +
               geom_density(aes(x = X2ndFlrSF),
                            fill = 'pink',color = 'deeppink') + 
               scale_x_continuous(breaks = seq(0,6000,1000),limits = c(0,7000)) + 
               GGvisualize_theme(),
             all %>% filter() %>% ggplot()+
               geom_density(aes(x = LowQualFinSF),
                            fill = 'pink',color = 'deeppink') + 
               GGvisualize_theme(),
             all %>% ggplot() +
               geom_density(aes(x = TotalBsmtSF),
                            fill = 'pink',color = 'deeppink') + 
               GGvisualize_theme(),
             all %>% filter(LotArea< 50000) %>% ggplot()+
               geom_density(aes(x = LotArea) ,
                            fill = 'pink',color = 'deeppink') + 
               GGvisualize_theme(),
             all %>% ggplot()+
               geom_density(aes(x = LotFrontage),
                            fill = 'pink',color = 'deeppink') + 
               GGvisualize_theme(),
             all %>% ggplot() +
               geom_density(aes(x = TotRmsAbvGrd),
                            fill = 'pink',color = 'deeppink') + 
               scale_x_continuous(breaks = seq(0,max(all$TotRmsAbvGrd))) + 
               GGvisualize_theme(),
             layout_matrix = matrix(1:8,4,2,byrow=TRUE))

```

GrLivArea: Above grade (ground) living area square feet
1stFlrSF: First Floor square feet
2ndFlrSF: Second floor square feet
LowQualFinSF: Low quality finished square feet (all floors)
TotalBsmtSF: Total square feet of basement area
LotArea: Linear feet of size in square feet
LotFrontage: Linear feet of street connected to property
TotRmsAbvGrd: Total rooms above grade (does not include bathrooms)

從圖形分佈來看似乎大部份的房子都只有1樓，把2樓X2ndFlrSF的部份加上1樓1stFlrSF分佈很接近GrLivArea，我做個相關性檢測一下。

```{r GrLivAreaEDA2,fig.height = 6, fig.width = 8,warning=F}
CorGrivArea <- cor(cbind(all[,c('SalePrice','GrLivArea','X1stFlrSF','X2ndFlrSF',
                                'LowQualFinSF','TotalBsmtSF','TotRmsAbvGrd',
                                'LotArea','LotFrontage')],
                         all$X1stFlrSF+all$X2ndFlrSF), 
                   use="pairwise.complete.obs") 
CorGrivArea_Sort <- sort(CorGrivArea[,'SalePrice'], 
                         decreasing = TRUE) %>%
                      names()
CorGrivArea[CorGrivArea_Sort, CorGrivArea_Sort] %>% 
  corrplot.mixed(tl.col="black", tl.pos = "lt")
```

從相關性檢測可以證明我的推測沒錯，1stFlrSF+2ndFlrSF和GrLivArea相關性等於1(其實也是廢話XD)。其實我本來以為GrLivArea只包含1樓，但是看了分佈圖與相關性圖後才發現可能還包含2樓。但是這邊還有另外一個問題1stFlrSF+2ndFlrSF的相關性竟然還比GrLivArea還高，也就是說1stFlrSF和2ndFlrSF還缺另外一個值才會等於GrLivArea。所以我會再這邊新增一個變數包含1stFlrSF+2ndFlrSF替代原本的GrLivArea。  
另外我會再新增一個特徵是GrLivArea+TotalBsmtSF叫做TotalArea，其包含地上坪數和地下室坪數。

```{r TotalArea,fig.height = 6, fig.width = 8,warning=F}
all$GrLivArea <- all$X1stFlrSF + all$X2ndFlrSF
all$TotalArea <- all$GrLivArea + all$TotalBsmtSF
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot(aes(x=TotalArea, y=SalePrice))+
  geom_point(color='blue') + 
  geom_smooth(method = "lm", se=FALSE, color="black", aes(group=1)) +
  scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma) +
  geom_text_repel(aes(label = ifelse(all$TotalArea[!is.na(all$SalePrice)]>7500,
                                     rownames(all), ''))) + 
  GGvisualize_theme()
```

組合出來的特徵相關性提高到0.782。

```{r TotalArea2}
cor(all$SalePrice, all$GrLivArea, use= "pairwise.complete.obs")
cor(all$SalePrice, all$TotalArea, use= "pairwise.complete.obs")
```

另外還要處理524與1299再前面就出現過的離群值，假如踢掉他們TotalArea相關性會提高5%。

```{r TotalArea3}
cor(all$SalePrice[-c(524, 1299)], 
    all$GrLivArea[-c(524, 1299)], 
    use= "pairwise.complete.obs")
cor(all$SalePrice[-c(524, 1299)], 
    all$TotalArea[-c(524, 1299)], 
    use= "pairwise.complete.obs")
```
最後在衡量時間與效益的考量下決定將這兩筆踢掉。


```{r TotalArea4}
all <- all[-c(524, 1299),]
```

### 地區

```{r NeighborhoodEda,fig.height = 6, fig.width = 8,warning=F}
grid.arrange(all %>% 
               filter(!(is.na(SalePrice))) %>%
               ggplot(aes(x=Neighborhood, y=SalePrice)) +
               stat_summary(geom ='bar',fun = "median",fill='steelblue') +
               stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
               scale_y_continuous(breaks= c(seq(0, 800000, by=50000),
                                            all[!is.na(all$SalePrice),'SalePrice'] %>% 
                                              median()), 
                                  labels = function(d){
                                             label = d/1000
                                             return(label)
                                                     }) +
               labs(y = 'SalePrice(千元)') +
               geom_label(stat = "count",
                          aes(label = ..count.., y = ..count..),
                          size=3) +
               geom_hline(yintercept= all[!is.na(all$SalePrice),'SalePrice'] %>% 
                                        median(), 
                          linetype="dashed", 
                          size = 2,
                          color = "red") +#銷售價格中位數
               GGvisualize_theme() +
               theme(axis.text.x = element_text(angle = 45, hjust = 1)),  
             all %>% ggplot(aes(x=Neighborhood)) +
               geom_histogram(stat='count')+
               geom_label(stat = "count", 
                          aes(label = ..count.., y = ..count..), 
                          size=3)+
               GGvisualize_theme() + 
               theme(axis.text.x = element_text(angle = 45, hjust = 1)))
```

上面是訓練資料的地區次數以及銷售價格的中位數，下圖是全資料集的各地區次數圖。
根據圖形呢，我會傾向把地區Neighborhood這個特徵依照SalePrice合併地區轉成平民區<中產區<富有區這樣並把它變成次序的來降維。

```{r NeighborhoodEda2,fig.height = 6, fig.width = 8,warning=F}
grid.arrange(ggplot(all[!is.na(all$SalePrice),], 
                    aes(x=reorder(Neighborhood, SalePrice, FUN=median), y=SalePrice)) +
               stat_summary(geom ='bar', fun = "median", fill='steelblue') + 
               stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
               labs(x='Neighborhood', y='Median SalePrice') +
               scale_y_continuous(breaks= seq(0, 800000, by=50000), labels = comma) +
               geom_label(stat = "count", 
                          aes(label = ..count.., y = ..count..),
                          size=3) +
               geom_hline(yintercept=all[!is.na(all$SalePrice),'SalePrice'] %>% median(),
                          linetype="dashed", color = "red") + #銷售價格中位數
               GGvisualize_theme() + 
               theme(axis.text.x = element_text(angle = 45, hjust = 1)) , 
             ggplot(all[!is.na(all$SalePrice),], 
                    aes(x=reorder(Neighborhood, SalePrice, FUN=mean), y=SalePrice)) +
               stat_summary(geom ='bar', fun = "mean", fill='steelblue') +
               stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
               labs(x='Neighborhood', y="Mean SalePrice") +
               scale_y_continuous(breaks= seq(0, 800000, by=50000), labels = comma) +
               geom_label(stat = "count", 
                          aes(label = ..count.., y = ..count..), size=3) +
               geom_hline(yintercept=all[!is.na(all$SalePrice),'SalePrice'] %>% mean(), 
                          linetype="dashed", color = "red")+ #銷售價格中位數
               GGvisualize_theme() +
               theme(axis.text.x = element_text(angle = 45, hjust = 1))
             ) 


```

我將地區依照銷售價格中位數(上圖)和平均數(下圖)排序並視覺化，我會將StoneBr、NridgHt和NoRidge合併成2(富有區)，將MeadowV、IDOTRR和BrDale合併成0(平民區)，剩下的變為1(中產區)。

```{r NeighborhoodEda3}
all$NeighCluster[all$Neighborhood %in% c('StoneBr', 'NridgHt', 'NoRidge')] <- 2
all$NeighCluster[!all$Neighborhood %in% c('MeadowV', 'IDOTRR', 'BrDale', 'StoneBr', 'NridgHt', 'NoRidge')] <- 1 
all$NeighCluster[all$Neighborhood %in% c('MeadowV', 'IDOTRR', 'BrDale')] <- 0

all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot( aes(x=NeighCluster, y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='deeppink3',width = 0.5) +
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..)) + 
  GGvisualize_theme()



```

看一下新組出來的變數和銷售價格的相關性0.5831，似乎沒有到像坪數那樣高相關性但也足夠了，在這邊為後續建模降了許多維。

```{r NeighborhoodEda4}
cor(all$SalePrice, all$NeighCluster, use= "pairwise.complete.obs")
```


### MSSubClass
MSSubClass: Identifies the type of dwelling involved in the sale.

* 20  1-STORY 1946 & NEWER ALL STYLES
* 30  1-STORY 1945 & OLDER
* 40  1-STORY W/FINISHED ATTIC ALL AGES
* 45  1-1/2 STORY - UNFINISHED ALL AGES
* 50  1-1/2 STORY FINISHED ALL AGES
* 60  2-STORY 1946 & NEWER
* 70  2-STORY 1945 & OLDER
* 75  2-1/2 STORY ALL AGES
* 80  SPLIT OR MULTI-LEVEL
* 85  SPLIT FOYER
* 90  DUPLEX - ALL STYLES AND AGES
* 120  1-STORY PUD (Planned Unit Development) - 1946 & NEWER
* 150  1-1/2 STORY PUD - ALL AGES
* 160  2-STORY PUD - 1946 & NEWER
* 180  PUD - MULTILEVEL - INCL SPLIT LEV/FOYER
* 190  2 FAMILY CONVERSION - ALL STYLES AND AGES


```{r MSSubClassEDA, warning=FALSE}
grid.arrange(ggplot(all[!is.na(all$SalePrice),], aes(x=MSSubClass, y=SalePrice)) +
               stat_summary(geom ='bar', fun = "median", fill='blue') +
               theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
               scale_y_continuous(breaks= seq(0, 800000, by=50000), labels = comma) +
               geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=3) +
               geom_hline(yintercept=163000, linetype="dashed", color = "red") +
               GGvisualize_theme() ,#dashed line is median SalePrice
             ggplot(data=all, aes(x=MSSubClass)) +
               geom_histogram(stat='count')+
               geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=3) +
               theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
               GGvisualize_theme() 
  
)
```

MSSubClass是用來區分房屋在銷售上的分別，要能將這個特徵組合或轉換其他更有力的特徵需要該領域的domain，這邊就跳過看看分佈。

### 車庫

GarageYrBlt第2593筆資料貌似Keyin錯誤，把它填補回2007。

```{r GarageYrBlt error}
all[2593,c('GarageYrBlt','YearBuilt','YearRemodAdd')]
```

看一下跟車庫有關的特徵分佈。

```{r GarageEDA, message=FALSE, warning=FALSE}
names(all)[names(all) %>% str_detect("Garage") %>% which]
all$GarageYrBlt[2593] <- 2007
grid.arrange(ggplot(data=all[all$GarageCars !=0,], aes(x=GarageYrBlt)) +
               geom_histogram() +
               GGvisualize_theme() ,
             ggplot(data=all[all$GarageCars !=0,], aes(x=YearBuilt)) +
               geom_histogram() +
               scale_x_continuous(limits = c(1890,2010))+
               GGvisualize_theme() ,
             ggplot(data=all, aes(x=as.factor(GarageCars))) +
               geom_histogram(stat='count') +
               GGvisualize_theme() ,
             ggplot(data= all, aes(x=GarageArea)) +
               geom_histogram() +
               GGvisualize_theme() ,
             ggplot(data=all, aes(x=as.factor(GarageCond))) +
               geom_histogram(stat='count') +
               GGvisualize_theme() ,
             ggplot(data=all, aes(x=GarageType)) +
               geom_histogram(stat='count') +
               GGvisualize_theme() ,
             ggplot(data=all, aes(x=as.factor(GarageQual))) +
               geom_histogram(stat='count') +
               GGvisualize_theme() ,
             ggplot(data=all, aes(x=as.factor(GarageFinish))) +
               geom_histogram(stat='count') +
               GGvisualize_theme() ,
              layout_matrix =matrix(c(1,2,3,4,6,6,5,7,8),3,3,byrow=TRUE)
  
)
```


這邊我把GarageYrBlt和YearBuilt放在一起觀察分佈，看起來許多房子在建立的時候就蓋好車庫了，本來預期分佈不一致的話這邊還可以試試組幾個有趣的特徵。



### 量化廁所數量

這邊我將每間房子廁所量化加總，一間廁所+1半間廁所+0.5。

```{r bathroom, message=FALSE, warning=FALSE}
names(all)[names(all) %>% str_detect("Bath") %>% which]
all$TotBathrooms <- all$FullBath + (all$HalfBath*0.5) + all$BsmtFullBath + (all$BsmtHalfBath*0.5)

grid.arrange(
  ggplot(data=all[!is.na(all$SalePrice),], 
         aes(x=as.factor(TotBathrooms), 
             y=SalePrice))+
    geom_point(col='blue') + 
    geom_smooth(method = "lm", se=FALSE, color="black", aes(group=1)) +
    labs(y = 'SalePrice(千元)')+
    scale_y_continuous(breaks= seq(0, 800000, by=100000), 
                       labels = function(d){
                            d/1000
                                  }) +
               GGvisualize_theme(),
  ggplot(data=all, aes(x=as.factor(TotBathrooms))) +
    geom_histogram(stat='count',width = 0.5)+
    GGvisualize_theme())

cor(all$SalePrice[!is.na(all$SalePrice)], all$TotBathrooms[!is.na(all$SalePrice)])
```

做出了一個有用的特徵，相關性有0.63。從上圖可以看出大部分的房子廁所數量都在2間左右，廁所數量越多銷售價格的標準差也就越大，其中5、6間反而銷售價格偏低，可能是因為房子是屬於郊區坪數大，房間廁所也多價格也相較便宜。但是基本上4間以下廁所的房屋還是能遵守這個規則。

### 屋齡

屋齡我再猶豫要使用改建年來減還是建造年來減會對預測有幫助，我索性兩個都建立並且都將其視覺化和計算相關性跟擬合一條迴歸線來觀察。

```{r age, message=FALSE}
all$Age <- as.numeric(as.character(all$YrSold))-all$YearRemodAdd
all$Age2 <- as.numeric(as.character(all$YrSold))-all$YearBuilt
library(ggpmisc)
grid.arrange(
  all[!is.na(all$SalePrice),] %>%
    ggplot(aes(x=Age, y=SalePrice))+
    geom_point(col='blue') + 
    geom_smooth(method = "lm", se=T,level = 0.95, color="black") +
    stat_poly_eq(formula =  y~x,
                 aes(label = paste(..rr.label..)), 
                 parse = TRUE)+
    scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma) +
    GGvisualize_theme(),
  all[!is.na(all$SalePrice),] %>%
    ggplot(aes(x=Age2, y=SalePrice))+
    geom_point(col='blue') + 
    geom_smooth(method = "lm", se=T, color="black", aes(group=1)) +
    stat_poly_eq(formula =  y~x,
                 aes(label = paste(..rr.label..)), 
                 parse = TRUE)+
    scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma) +
    GGvisualize_theme()
  
)
cor(all$SalePrice[!is.na(all$SalePrice)], all$Age[!is.na(all$SalePrice)])
cor(all$SalePrice[!is.na(all$SalePrice)], all$Age2[!is.na(all$SalePrice)])
```

從圖形上來看似乎用Age2(建造年分)會比較，圖形上的各點似乎比較貼近擬合的迴歸線。另外擬合的迴歸線R平方也是Age2比較好一些，雖然也沒提高多少。相關性也是Age2比較高，所以就決定用建造年分來當屋齡相減的計算。

製作屋齡後發現，屋齡與銷售價格呈現中等的負相關，越舊的房子銷售價格越低，房子似乎沒有想像中的保值。我會分別製作是否改建以及是否為新屋的特徵，並且測試看看他們的效果。

```{r age2, message=FALSE}
all$Age2 <- NULL
all$Age <- as.numeric(as.character(all$YrSold))-all$YearRemodAdd
```


### 是否改建

這邊我根據是否改建嘗試組出一個新特徵，並將其視覺化。

```{r Remod}
all$Remod <- ifelse(all$YearBuilt==all$YearRemodAdd, 0, 1) 
ggplot(all[!is.na(all$SalePrice),], aes(x=as.factor(Remod), y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='black',width = 0.5) +
  geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=6) +
  scale_y_continuous(breaks= seq(0, 800000, by=50000), labels = comma) +
  theme_grey(base_size = 18) +
  geom_hline(yintercept=163000, linetype="dashed") +
  GGvisualize_theme()
```

上圖是根據是否改建分組後各組的銷售價格中位數，黑色是標準差、黑色虛線則是整體銷售價格的中位數。可以看出有改建過後的房子其銷售價格比較低，可能反應未改建(都更)的房子比較有價值，這可能跟地區有關。


```{r Remod2}
ggplot(all[!is.na(all$SalePrice),], aes(x=as.factor(Remod), y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='dodgerblue2') +
  stat_summary(geom ='bar', fun = "sd", fill='black',width = 0.5) +
  geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=6) +
  scale_y_continuous(breaks= seq(0, 800000, by=50000), labels = comma) +
  theme_grey(base_size = 18) +
  facet_wrap(NeighCluster~.)+
  geom_hline(yintercept=163000, linetype="dashed") +
  GGvisualize_theme()
```

我將改建和地區交叉視覺化後發現富有地區比較傾向改建後的房子比較有價值，像大安區或信義區改建過後的新房子總是比較吸引人比較貴。中產地區房屋量為最大宗其未改建的房子銷售價格比較貴一點，就像南港萬華北投等比較蛋白的地區，還有許多正在等待改建的老房子，可能10年後這張圖的銷售價格比例就會有大幅變化也不一定。

另外我還做了無母數檢定kruskal.test來檢定改建這個新特徵其分組的銷售價格中位數有無顯著上差異，報表上檢定出來是顯著拒絕虛無假設(中位數無差異)，雖然我覺得好像差異並不大但是單位畢竟是美金...

```{r Remod3}
kruskal.test(data = all[!is.na(all$SalePrice),],SalePrice ~ Remod) 

```

### 是否新屋

這邊我想新增一個特徵來判斷它是否為新屋，首先要先定義屋齡幾年以下的房屋為新屋？通常這需要房地產領域的知識，那如果我們沒有怎辦呢？那就隨意訂個比較合理的新屋屋齡最大值，然後從0計算到最大值的中位數價格差、標準差以及包含房屋數量來做個簡易分析比較吧！

```{r isNew}

SalePriceDiff <- data.frame()
for (i in 0:5) {
  all$IsNew <- ifelse(as.numeric(as.character(all$YrSold)) - all$YearBuilt <= i, 1, 0)
  medianDiff <- 
    median(all[all$IsNew == 1 & !is.na(all$SalePrice),'SalePrice']) -
    median(all[all$IsNew == 0 & !is.na(all$SalePrice),'SalePrice'])
  SalePriceDiff <- rbind(SalePriceDiff, 
                         data.frame(
                           year = i,
                           medianDiff = medianDiff,
                           sd_0 =  
                             sd(all[all$IsNew == 0 & !is.na(all$SalePrice),'SalePrice']),
                           sd_1 =  
                             sd(all[all$IsNew == 1 & !is.na(all$SalePrice),'SalePrice']),
                           IsNewNum = table(all$IsNew)[2],
                           IsNewNum_train = table(all[!is.na(all$SalePrice),'IsNew'])[2]
                           )
                         )
}
SalePriceDiff
```

從中位數價格差來看屋齡0年使分組差異達到最大再來是1和3年，但是0年包含的訓練資料筆數只有62筆，有點少！1、3年看起來比較理想，價格差在84000包含資料筆數又多。1~2年訓練資料多納入了100筆和39筆中位數皆使中位數差縮小，到3年增加36筆資料又把中位數差拉回來。這樣的數據其實挺有趣的，如果在第3年這一塊增加的36筆數據都是偏高價位，是不是能做一個假設：買新房做投資的投資客大概都在3年之間脫手?當然要驗證這件事可能還需要搭配物件的歷史成交資訊來分析，但也不是目前的重點就先跳過XD。  

另外，從標準差角度切入0年的分組1是最小的但是0的標準差是最大的。想挑屋齡3年以下的分組界線，但是簡易分析又不太符合我所想要的預期(屋齡界線提高、價格差異下降幅大不大、組內變異低、包含資料筆數多)，我再多做個簡易單迴歸協助我判斷。


```{r isNew2}

SalePriceDiff <- data.frame()
for (i in 0:5) {
  all$IsNew <- ifelse(as.numeric(as.character(all$YrSold)) - all$YearBuilt <= i, 1, 0)
  medianDiff <- 
    median(all[all$IsNew == 1 & !is.na(all$SalePrice),'SalePrice']) -
    median(all[all$IsNew == 0 & !is.na(all$SalePrice),'SalePrice'])
  lm_isnew <- lm(log(all$SalePrice)~all$IsNew) %>% summary
  SalePriceDiff <- rbind(SalePriceDiff, 
                         data.frame(
                           year = i,
                           medianDiff = medianDiff,
                           IsNewNum = table(all$IsNew)[2],
                           IsNewNum_train = table(all[!is.na(all$SalePrice),'IsNew'])[2],
                           rmse = lm_isnew$sigma,
                           rSquare = lm_isnew$adj.r.squared
                         )
  )
}
SalePriceDiff
```

根據簡單迴歸呢，看起來好像應該選5年以內，但我覺得銷售價格差下降太多了，0年R平方太低沒甚麼效益，果然還是3年以內最合適。  

```{r isNew3}
all$IsNew <- ifelse(as.numeric(as.character(all$YrSold)) - all$YearBuilt <= 3, 1, 0)
table(all$IsNew)
ggplot(all[!is.na(all$SalePrice),], aes(x=as.factor(IsNew), y=SalePrice)) +
  stat_summary(geom ='bar', fun = "median", fill='steelblue') +
  stat_summary(geom ='bar', fun = "sd", fill='black',width = 0.5) +
  geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=6) +
  scale_y_continuous(breaks= seq(0, 800000, by=50000), labels = comma) +
  theme_grey(base_size = 18) +
  geom_hline(yintercept=163000, linetype="dashed") +
  GGvisualize_theme()


```

然後呢，再製作這個簡單迴歸分析時突然有個idea，如果我將屋齡分類的簡單迴歸效益評比擴展到60呢?換句話說，嘗試從屋齡分界找出一個臨界點能比較有效的預測銷售價格，而其代表的意義可能是在那屋齡年限內人們將房屋賣掉所能獲取最大利益價格，也就是市場上最大所能偏好幾年以內的房子。

###  最大偏好屋齡

```{r IsNewMax}
SalePriceDiff <- data.frame()
for (i in 0:60) {
  all$IsNewMax <- ifelse(as.numeric(as.character(all$YrSold)) - all$YearBuilt <= i, 1, 0)
  medianDiff <- 
    median(all[all$IsNewMax == 1 & !is.na(all$SalePrice),'SalePrice']) -
    median(all[all$IsNewMax == 0 & !is.na(all$SalePrice),'SalePrice'])
  lm_isnew <- lm(log(all$SalePrice)~all$IsNewMax) %>% summary
  SalePriceDiff <- rbind(SalePriceDiff, 
                         data.frame(
                           year = i,
                           medianDiff = medianDiff,
                           IsNewNum = table(all$IsNewMax)[2],
                           IsNewNum_train = table(all[!is.na(all$SalePrice),'IsNewMax'])[2],
                           rmse = lm_isnew$sigma,
                           rSquare = lm_isnew$adj.r.squared
                         )
  )
}
SalePriceDiff
grid.arrange(
  SalePriceDiff %>%  
    ggplot(aes(x = year,y = rSquare,group = 1)) + 
    geom_point() +
    geom_vline(xintercept  = 22,linetype = 'dashed') +
    geom_text(aes(label = round(rSquare,3)),
              color = ifelse(max(SalePriceDiff$rSquare) == SalePriceDiff$rSquare,
                             'red','transparent'),
              vjust = 1.5,
              size = 5) + 
    scale_x_continuous(
      breaks = c(seq(0,60,10),
                 SalePriceDiff[which(SalePriceDiff$rSquare == max(SalePriceDiff$rSquare)),
                               'year'])) +
    geom_line() + 
    GGvisualize_theme(),
  SalePriceDiff %>%  
    ggplot(aes(x = year,y = medianDiff)) + 
    geom_bar(stat = 'identity') +
    geom_vline(xintercept  = 22,linetype = 'dashed') +
    geom_text(aes(label = medianDiff),
              color = ifelse(max(SalePriceDiff$rSquare) == SalePriceDiff$rSquare,
                             'red','transparent'),
              vjust = -0.75,
              size = 5) + 
    scale_y_continuous(labels = function(d){
      d/10000
    },limits = c(0,110000),name = '分組中位數差(萬元)')+
    scale_x_continuous(
      breaks = c(seq(0,60,10),
                 SalePriceDiff[which(SalePriceDiff$rSquare == max(SalePriceDiff$rSquare)),
                               'year'])) +
    GGvisualize_theme()
  
)
rm(SalePriceDiff)

```
我選擇屋齡界限在22年以內，原因是它為R平方的最大值，從它之後開始慢慢遞減。不過實際上從上圖可以確認其實從大約屋齡30年不僅是R平方，銷售價格組間中位數差也開始明顯下降。

## 模型準備

踢掉高相關性的變數

```{r modelPrepare1}
dropVars <- c('YearRemodAdd', 'GarageYrBlt', 'GarageArea', 
              'GarageCond', 'TotalBsmtSF', 'TotalRmsAbvGrd', 
              'BsmtFinSF1')
all <- all[,!(names(all) %in% dropVars)]
```

統計變數類別

```{r modelPrepare2}
numericVarNames <- which(sapply(all, is.numeric)) %>% names()
numericVarNames <- numericVarNames[!(numericVarNames %in%
                                       c('SalePrice','Id'))] 

DFnumeric <- all[, names(all) %in% numericVarNames]

DFfactors <- all[, !(names(all) %in% numericVarNames)]
DFfactors <- DFfactors[, !names(DFfactors) %in% c('SalePrice','Id')] 
cat('數值變數:', length(DFnumeric),'\n類別變數',length(DFfactors))

```

### 去掉偏態

連續型特徵如果分佈明顯偏一邊，在預測上容易產生誤差。理論上去掉偏態讓資料趨近於常態會比較理想，試想今天如果一個特徵與目標特徵高度正相關，但是這個特徵卻極度右偏，那在歸納權重的時候該特徵越高不就越容易預測錯誤？

以下程式碼將檢測每個數值特徵的偏態，大於0.5我就把它用log轉換(+1是避免0轉換不了)。

```{r skew}
for(i in 1:ncol(DFnumeric)){
  if (abs(psych::skew(DFnumeric[,i]))>0.5){
    DFnumeric[,i] <- log(DFnumeric[,i]+1)
  }
}
```

### 標準化

連續型特徵會因為單位的不同而在模型權重上的歸納產生嚴重的影響，換句話說不同單位間的特徵能被放在一起比較？年齡20~26歲跟年薪200,000~260,000所計算出的權重會是等值的？  

標準化還有另外幾個好處，因為標準化屬於特徵縮放的一種它能夠加快機器學習的收斂。另外經過標準化的特徵其分佈更容易變成常態分佈。

這邊我利用caret套件的`preProcess`進行標準化。

```{r scale}
PreNum <- preProcess(DFnumeric, method=c("center", "scale")) #caret
print(PreNum)

DFnorm <- predict(PreNum, DFnumeric)
dim(DFnorm)
```

### One Hot Enoding

將類別數據轉換成數字表示使模型能夠進行計算，One Hot Enoding對於類別特徵，如果他有m個類別值則會形成m個二元特徵，並且這些特徵彼此會互斥不會有同時為1的情況發生，換句話說就是把單一類別特徵轉換成稀疏矩陣的概念。

這邊我利用caret套件的`dummyVars`進行One Hot Encoding，並踢掉在train或test data裡分別小於等於10的類別變數，因為數量稀少對預測影響不大又能降維。

```{r One Hot Encoding}
PreFac <- dummyVars(" ~ .", data = DFfactors)
DFdummies <- data.frame(predict(PreFac, DFfactors))
dim(DFdummies)

#踢掉在train或test data裡分別小於等於10的類別變數
#test
Tencol_test <- 
  which(DFdummies[all$SalePrice %>% is.na %>% which,] %>% 
          colSums() <= 10)
colnames(DFdummies[Tencol_test])
DFdummies <- DFdummies[,-Tencol_test] 

#train
Zerocol_train <- 
  which(DFdummies[which(!(all$SalePrice %>% is.na)),] %>% 
          colSums() <= 10)
colnames(DFdummies[Zerocol_train])
DFdummies <- DFdummies[,-Zerocol_train]
modelData <- cbind(DFnorm, DFdummies) 

```


### 目標特徵的偏態

前面EDA部分一開始就先討論過了目標特徵的右偏分佈，如果太過於右偏的話模型預測結果對於高房價的房子可能誤差會比較大，所以這部分除了透過畫出分佈圖之外，我還會運用計算偏態以及繪出QQ圖來協助我判斷。

```{r SalePrice Skewness}
 
all %>% 
  filter(!(is.na(SalePrice))) %>% 
  ggplot(aes(x = SalePrice )) + 
  geom_histogram(fill="deeppink2",
                 binwidth = 10000) +
  scale_x_continuous(breaks= seq(0, 800000, by=100000),
                     labels = comma)+
  theme_bw() + #去掉背景色
  theme(panel.grid=element_blank(),  #去掉網線
        panel.border=element_blank(),#去掉邊線
        axis.line=element_line(size=1,colour="black")) +
  annotation_custom(tableGrob(summary(all$SalePrice) %>%
                                "["(1:3) %>% as.matrix() %>% 
                                t,rows = NULL), 
                    xmin=400000, xmax=700000, 
                    ymin=75, ymax=150)+
  annotation_custom(tableGrob(summary(all$SalePrice) %>% 
                                round() %>%
                                "["(4:6) %>% 
                                as.matrix() %>% 
                                t,rows = NULL), 
                    xmin=400000, xmax=700000, 
                    ymin=75, ymax=100)

psych::skew(all$SalePrice)
qqnorm(all$SalePrice)
qqline(all$SalePrice)

```

透過分佈圖形可以確認銷售價格為典型右偏，偏態係數高達1.877427，QQ圖也顯示低房價以及中高以上的房價偏離標準線。這情況必須修正回來，我是習慣使用log轉換，當然另外也有常用的Box-Cox轉換。


```{r SalePrice Skewness2}
 
all$SalePrice <- log(all$SalePrice) 
psych::skew(all$SalePrice)
qqnorm(all$SalePrice)
qqline(all$SalePrice)

```

經過轉換後偏態係數更接近0，但是透過QQ圖發現房價頭尾的房子還是會些微偏離標準線。


### 建模用與預測上傳用

```{r train&test}
train <- modelData[!is.na(all$SalePrice),]
test <- modelData[is.na(all$SalePrice),]

```


# 建模

## Lasso 迴歸

```{r Lasso}
set.seed(27042018)
my_control <-trainControl(method="cv", number=5)
lassoGrid <- expand.grid(alpha = 1,  #1 = lasso,0 = ridge
                         lambda = seq(0.001,0.1,by = 0.0005)#懲罰項
                         )

lasso_mod <- train(x=train, 
                   y=all$SalePrice[!is.na(all$SalePrice)], 
                   method='glmnet', 
                   trControl= my_control, 
                   tuneGrid=lassoGrid) 
lasso_mod$bestTune
min(lasso_mod$results$RMSE)

```

使用Lasso迴歸本來是想達到特徵選擇來進行降維目的，使模型表現更好。但是呢我使用經過Lasso所挑出來的變數下去Train Xgboost的效果並沒有比較好，反而上傳的RMSE多出了0.05，所以後面的特徵還是選用原本的特徵。

其實Xgboost經過特徵選擇後沒有表現比較好想想其實也挺正常的，畢竟人家演算法過程中也是有經過類似隨機森林那樣特徵抽選構建樹，又經過貪婪方式來搜尋最大可能。我想之後等哪天有空要將這個專案擴充做更大的演算法架構，例如多建幾個模型，多做一層stacking那Lasso的效果就會出來了吧！

```{r Lasso1}
LassoPred <- predict(lasso_mod, test)
predictions_lasso <- exp(LassoPred) 
head(predictions_lasso)
```


## Xgboost

### 調參準備

其實真要tune 超參數的話真的有一大堆要tune，但是受限於貧窮的設備限制，只好先tune幾個比較常見的．另外最近在研究AWS和AZURE等雲端計算的服務，等摸熟了之後設備升級我就能tune更多參數組合啦！

下面的調參大約要跑一個多小時(i5-8300H 20G RAM)

```{r xgboost}
xgb_grid = expand.grid(
  nrounds = 1000,
  eta = c(0.05, 0.01),
  max_depth = c(2, 3, 4, 5, 6),
  gamma = 0,
  colsample_bytree=1,
  min_child_weight=c(1, 2, 3, 4 ,5),
  subsample=1
)

# xgb_caret <- train(x=train[,varsSelected],
#                   y=all$SalePrice[!is.na(all$SalePrice)], 
#                   method='xgbTree', trControl= my_control, 
#                   tuneGrid=xgb_grid) 
# xgb_caret$bestTune

default_param<-list(
  objective = "reg:linear",
  booster = "gbtree",
  eta=0.05,
  gamma=0,
  max_depth=3, 
  min_child_weight=2, 
  subsample=1,
  colsample_bytree=1
)
label_train <- all$SalePrice[!is.na(all$SalePrice)]
# 將資料轉換成Xgb.DMatrix
dtrain <- xgb.DMatrix(data = as.matrix(train), 
                      label= label_train)
dtest <- xgb.DMatrix(data = as.matrix(test))
```

### CV

```{r xgboost2}
set.seed(27042018)
xgbcv <- xgb.cv(params = default_param,
                data = dtrain,
                nrounds = 1000,
                nfold = 10, showsd = T,
                stratified = T,
                print_every_n = 40,
                maximize = F)
xgbcv$evaluation_log$test_rmse_mean %>% which.min() 
xgbcv$evaluation_log$test_rmse_mean %>% min()
```

### 建模&預測

```{r xgboost3}
set.seed(27042018)
xgb_mod <- xgb.train(data = dtrain, 
                     params=default_param, 
                     nrounds = 688)
XGBpred <- predict(xgb_mod, dtest)
predictions_XGB <- exp(XGBpred) 
head(predictions_XGB)

```

### 特徵重要性

```{r xgboost4}
library(Ckmeans.1d.dp) #required for ggplot clustering
mat <- xgb.importance (feature_names = colnames(train),
                       model = xgb_mod)
xgb.ggplot.importance(importance_matrix = mat[1:30], 
                      rel_to_first = TRUE)

```


## 簡易Bagging

因為Lasso在CV的測試集上比較低，我給他的預測權重比Xgboost大一點，比例會是Lasso 2 : Xgboost 1。最後輸出結果並上傳至Kaggle，結案！

```{r bagging}
sub_avg <- data.frame(Id = test_labels, 
                      SalePrice = (predictions_XGB+2*predictions_lasso)/3)
head(sub_avg)
# write.csv(sub_avg, 
#           file = 'output/housesale.csv',
#           row.names = F)
```

