---
title: "kaggle_housesale"
author: "RenardBao"
date: "2018年12月24日"
output: 
  html_document:
    theme: journal
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: TRUE
      smooth_scroll: TRUE
---
```{r,include=FALSE}
knitr::opts_knit$set(root.dir ="D:/r_project/data-analysis/house_sale_predict")

```

<style> p{line-height: 2em;}</style>
#前言
> Ask a home buyer to describe their dream house, and they probably won't begin with the height of the basement ceiling or the proximity to an east-west railroad. But this playground competition's dataset proves that much more influences price negotiations than the number of bedrooms or a white-picket fence.  

>  With 79 explanatory variables describing (almost) every aspect of residential homes in Ames, Iowa, this competition challenges you to predict the final price of each home.


這次的資料是來自於[Kaggle](https://www.kaggle.com/c/house-prices-advanced-regression-techniques)，題目是要預測美國愛荷華州的埃姆斯城市的房價。我會進行資料探索、特徵工程和一些資料視覺，最後我會運用LASSO迴歸、XGBoost和SVM來建模，目前我是第885名(TOP19%)。

#前置作業

以下是這次會用到的套件
```{r, result = "hide",warning=FALSE,message=FALSE}
library(ggplot2)
library(dplyr)
library(corrplot)
library(caret)
library(gridExtra)
library(scales)
library(ggrepel)
library(randomForest)
library(psych)
library(xgboost)
library(magrittr)
library(stringr)
```


先做一些環境設置。

```{r}

options(scipen = 999)
train <- read.csv("train.csv", stringsAsFactors = F)
test <- read.csv("test.csv", stringsAsFactors = F)
#之後submission要用到test$id
test_labels <- test$Id
#test資料集沒有saleprice,用NA填補
test$SalePrice <- NA
all <- rbind(train, test)
dim(all)
```


瞄一下資料的結構

```{r}
#因為有長達80個變數,這邊先簡單顯示前15個跟目標變數
str(all[,c(1:15,80)])
```

```{r,message=FALSE,warning=FALSE}
num_var <-  sapply(all, is.numeric) %>% which %>% names()
char_var <- sapply(all, is.character) %>% which %>% names()
cat("數值變數有",length(num_var),"個",",類別變數有",length(char_var),"個")
```

#探索資料
##目標變數--銷售價格

看下圖可以發現我們的目標變數"銷售價格"，是一個明顯的右偏峰態。想一想其實也很合理，市場上絕大多數的消費者都負擔不起昂貴的房子。如果圖形呈現左偏或者常態峰佈，代表該地區房價偏貴，或許是屬於高級住宅區也不一定。後面我會將銷售價格做log處理將數據轉換成比較符合常態分佈。
```{r saleprice plot}
all %>% filter(!(is.na(SalePrice))) %>% 
  ggplot(aes(x = SalePrice)) + 
  geom_histogram(fill="deeppink2",
                 binwidth = 10000) +
  scale_x_continuous(breaks= seq(0, 800000, by=100000),
                     labels = comma)+
  theme_bw() + #去掉背景色
  theme(panel.grid=element_blank(),  #去掉網線
        panel.border=element_blank(),#去掉邊線
        axis.line=element_line(size=1,colour="black"))#加深XY線軸


summary(all$SalePrice)

```

##數值變數和目標變數的相關性
探索資料第二個步驟就是觀察各個變數和目標變數之間的相關性了，好讓我之後特徵工程比較好處理。

```{r corplot, fig.height = 10, fig.width = 14}
cor_numvar <- cor(all[, num_var], use="pairwise.complete.obs")
#排序之後挑出去相關性絕對值大於0.4的
cor_sortname <- sort(cor_numvar[,'SalePrice'], decreasing = TRUE) %>% 
                 as.matrix() %>% apply(1, function(x) abs(x)>0.15) %>% 
                 which() %>% names()
cor_numvar_sort <- cor_numvar[cor_sortname, cor_sortname]
#相關性視覺化
corrplot.mixed(cor_numvar_sort, tl.col="black", tl.pos = "lt")

```

透過上圖，相關性大於0.5的變數大概有10個、大於0.7則有兩個(OverallQual & GrLivArea)。後面剩餘的相關性章節我會再獨立出OverallQual & GrLivArea這兩個高相關性變數來個別視覺化其和目標變數的關係。

另外，變數間的共線性問題也要處理。例如GargeCars和GargeArea(0.89)、X1stFlrSF和TotalBsmtSF(0.8)、TotRmsAbvGrd和GrLivArea(0.81)、GarageYrBlt和YearBuilt(0.83)等等，這些會在後面特徵工程的部分進行處理。


##OverallQual
```{r OverallQual_visual, fig.height = 10, fig.width = 14}
grid.arrange(all %>% filter(!(is.na(SalePrice))) %>% 
              ggplot(aes(x=factor(OverallQual), y=SalePrice))+
              geom_boxplot(col='dodgerblue2') + 
              labs(x='Overall Quality') +
              scale_y_continuous(breaks= seq(0, 800000, by=100000),
                                 labels = comma),
             all %>% filter(!(is.na(SalePrice))) %>% 
              ggplot(aes(x=OverallQual, y=SalePrice))+
              geom_point(col='dodgerblue2') + 
              geom_smooth(method = "lm", se=FALSE, color="deeppink3") +
              scale_x_continuous(breaks = seq(1,10,1))+
              scale_y_continuous(breaks= seq(0, 800000, by=100000), 
                                 labels = comma))


```
OverallQual和銷售價格明顯的呈現正相關，而且OverallQual越高銷售價格距離也越大(離散程度)。從箱型圖上看來，沒有差異很大的離群值要踢掉，比較明顯的大概是OverallQual第4和第10。

##GrLivArea
```{r GrLivArea, fig.height = 10, fig.width = 14}
all %>% filter(!(is.na(SalePrice))) %>% 
  ggplot(aes(x=GrLivArea, y=SalePrice))+
  geom_point(col='dodgerblue2') + 
  geom_smooth(method = "lm", se=FALSE, color="deeppink3") +
  scale_y_continuous(breaks= seq(0, 800000, by=100000), 
                     labels = comma) +
  geom_text_repel(aes(label = ifelse(all$GrLivArea[!is.na(all$SalePrice)]>4500, rownames(all), '')))


```

看起來右下角似乎有怪異的離群值(524,299)，理論上來說居住坪數越高銷售價格應該也不會低到哪裡去。

```{r see_outlier}
#觀察outlier
all[c(524, 1299), c('SalePrice', 'GrLivArea', 'OverallQual')]

```

524和1299這對兄弟超奇怪的，OverallQual的分數為10、GrLivArea又是屬於前段班，照理來說房價應該會貴到天際才對。但是我在這邊暫時先不會踢掉這兩筆資料，他們會列入可疑名單並在後續特徵工程的時候會再拿出來討論，畢竟貿然地踢掉資料是一個奢侈又高風險的行為。

##觀察NA值
來看看哪些變數包含NA值。

```{r NA, fig.height = 10, fig.width = 14}
all[is.na(all) %>% colSums %>% ">"(0) %>% which] %>% 
  sapply(is.na) %>% colSums() %>% sort(decreasing = TRUE) 
```

我將會在後面特徵工程時連同重新編碼、轉換變數時一併處理NA值。

#特徵工程
##資料清洗
###Pool
```{r}
names(all)[names(all) %>% str_detect("Pool") %>% which]
```

####PoolQC
2909個NA  
PoolQC: Pool quality

*  Ex   Excellent
*  Gd   Good
*  TA   Average/Typical
*  Fa   Fair
*  NA   No Pool


```{r}
table(all$PoolQC)

all$PoolQC[is.na(all$PoolQC)] <- 'None'
all$PoolQC<-as.integer(plyr::revalue(all$PoolQC,
                                     c('None' = 0, 'Po' = 1, 
                                       'Fa' = 2, 'TA' = 3,
                                       'Gd' = 4, 'Ex' = 5)))
all %>% filter(!(is.na(SalePrice)) & PoolQC != 0) %>% 
  ggplot(aes(x = OverallQual, 
             y = SalePrice,
             color = as.factor(PoolQC),
             alpha = PoolArea)) +
  geom_point(size = 5)

```

有游泳池的房子只有10間，圖形上顯示Pool相關變數似乎不那麼顯著影響房價，右上角的資料應該有其他變數影響。後面特徵工程的時候我或許會把這類別變數轉成是否有游泳池就好，評級可能不太需要。在這邊我先把NA值轉成NO，並且把它轉成類別變數。

####PoolArea
另一個跟Pool有關的是PoolArea:

```{r}
table(all$PoolArea != 0 )
```

竟然有13個值(PoolQC只有10個)。

```{r}
all[all$PoolArea>0 & all$PoolQC == 0, c('SalePrice','PoolArea', 'PoolQC', 'OverallQual')]
```

這三個疑似缺漏值的資料出現在要預測的資料集裡面，我們也不能隨便亂刪掉，只好透過觀察現有的10筆資料來填補PoolQC回去。

```{r}
all[all$PoolArea > 0,] %>% ggplot(aes(x = OverallQual,y = PoolArea,color = PoolQC)) + 
  geom_point(size = 5) +
  geom_text_repel(aes(label = ifelse(all[all$PoolArea > 0,"PoolArea"]> 0,
                                     rownames(all[all$PoolArea > 0,]),
                                     "")))
```


透過上圖我會把這三個值都填2回去比較合理。

```{r}
all$PoolQC[2421] <- 2
all$PoolQC[2504] <- 2
all$PoolQC[2600] <- 2
all[all$PoolArea > 0,] %>% ggplot(aes(x = OverallQual,y = PoolArea,color = PoolQC)) + 
  geom_point(size = 5) +
  geom_text_repel(aes(label = ifelse(all[all$PoolArea > 0,"PoolArea"]> 0,
                                     rownames(all[all$PoolArea > 0,]),
                                     "")))

```


###Miscellaneous Feature
```{r}
names(all)[names(all) %>% str_detect("Mis") %>% which]
```

2814個NA
MiscFeature: Miscellaneous feature not covered in other categories

* Elev Elevator
* Gar2 2nd Garage (if not described in garage section)
* Othr Other
* Shed Shed (over 100 SF)
* TenC Tennis Court
* NA   None 

轉成factor。

```{r MiscFeature}
all$MiscFeature[is.na(all$MiscFeature)] <- "None"
all$MiscFeature <- as.factor(all$MiscFeature)
all %>% filter(!(is.na(SalePrice))) %>% 
  ggplot(aes(x=MiscFeature, y=SalePrice)) +
  geom_bar(stat='summary', fun.y = "median", fill='dodgerblue2') +
  scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma) +
  geom_label(stat = "count", aes(label = ..count.., y = ..count..))
table(all$MiscFeature)

```


看起來MiscFeature這類別變數沒甚麼相關，絕大多數都是None居多。第二多的shed也沒有明顯和None有差異，差異比較大的TenC和Othr佔的件數又少很多。

####MiscVal
```{r}
all %>% filter(!(MiscFeature %in% "None") & MiscVal == 0) %>% select("Id","MiscVal","MiscFeature")
```


這三筆資料我不會去更動它，因為我並不知道價值為0是因為誤植還是它真的就是免費大贈送的。



###Alley
2721個NA
Alley: Type of alley access to property

* Grvl Gravel
* Pave Paved
* NA   No alley access

轉成factor。

```{r Alley}
all$Alley[is.na(all$Alley)] <- 'None'
all$Alley %<>% as.factor()
all %>% filter(!(is.na(SalePrice))) %>% 
  ggplot(aes(x=Alley, y=SalePrice)) +
  geom_bar(stat='summary', fun.y = "median", fill='dodgerblue2')+
  scale_y_continuous(breaks= seq(0, 200000, by=50000), labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..))
table(all$Alley)
```

###Fence
2348個NA
Fence: Fence quality

* GdPrv    Good Privacy
* MnPrv    Minimum Privacy
* GdWo Good Wood
* MnWw Minimum Wood/Wire
* NA   No Fence

```{r}
all$Fence[is.na(all$Fence)] <- 'None'
table(all$Fence)
all %>% filter(!(is.na(SalePrice))) %>%
  ggplot(aes(x=Fence, y=SalePrice)) +
  geom_bar(stat='summary', fun.y = "median", fill='dodgerblue2')+
  scale_y_continuous(labels = comma) + 
  geom_label(stat = "count",aes(label = ..count..,y = ..count..))
all$Fence <- as.factor(all$Fence)

```

看起來沒有明顯的次序關係，沒有Fence的房屋價格比較高，所以轉成factor。

###Fireplace
```{r}
names(all)[names(all) %>% str_detect("Fireplace") %>% which]
```

####FireplaceQu
1420個NA
* Ex   Excellent - Exceptional Masonry Fireplace
* Gd   Good - Masonry Fireplace in main level
* TA   Average - Prefabricated Fireplace in main living area or Masonry  Fireplace in basement  
* Fa   Fair - Prefabricated Fireplace in basement
* Po   Poor - Ben Franklin Stove
* NA   No Fireplace

像這種在變數說明或者常理上能夠認知是有次序的，我都會把他轉成數值。

```{r FireplaceQu}
all$FireplaceQu[is.na(all$FireplaceQu)] <- 'None'
all$FireplaceQu<-as.integer(plyr::revalue(all$FireplaceQu,
                                          c('None' = 0, 'Po' = 1, 
                                            'Fa' = 2, 'TA' = 3,
                                            'Gd' = 4, 'Ex' = 5)))
table(all$FireplaceQu)

```

####Fireplaces
```{r}
table(all$Fireplaces)
sum(table(all$Fireplaces))
```

###Lot
```{r Lot}
names(all)[names(all) %>% str_detect("Lot") %>% which]
```

####LotFrontage
LotFrontage: Linear feet of street connected to property
486個NA
初步建模我先根據房屋所在地區的中位數來填補。為什麼呢？拿台灣來說吧，嘉義縣的房子大部分來說要到街上肯定比台北市的房子去到街上還要遠，這就是郊區跟市區的差別。但是這樣還是會有偏誤，以台北市來說北投區內湖區有可能會比中正區信義區還要來的遠，也就是說城市內部也會存在著很大的差異。下一次我有可能會針對這個變數單獨建一個模型來估計它的遺漏值。

```{r LotFrontage_plot,fig.height = 10, fig.width = 14}
all %>% ggplot( aes(x=as.factor(Neighborhood), y=LotFrontage)) +
  geom_bar(stat='summary', fun.y = "median", fill='dodgerblue2') +
  geom_bar(stat='summary', fun.y = "sd", color='deeppink3') +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major=element_line(colour=NA)) 
```

藍色是中位數，咖啡色是標準差。從圖上可以看出部分城鎮跟城鎮以及區域跟區域之間存在著上述所講的差異。

```{r LotFrontage}
#利用dplyr結合ifelse進行向量式填補
all %<>% group_by(Neighborhood) %>% 
         mutate(LotFrontage = ifelse(is.na(LotFrontage),
                                     median(LotFrontage,na.rm = T),
                                     LotFrontage)) %>% 
         as.data.frame()
```


####LotShape
沒有NA

* Reg  Regular 
* IR1  Slightly irregular
* IR2  Moderately Irregular
* IR3  Irregular

應該是有次序的變數，把它轉成數值變數。

```{r LotShape}
table(all$LotShape)
#將其轉換為數字
all$LotShape<-as.integer(revalue(all$LotShape,
                                 c('IR3'=0, 'IR2'=1,
                                   'IR1'=2, 'Reg'=3)))
table(all$LotShape)
```


####LotConfig
沒有NA

* Inside   Inside lot
* Corner   Corner lot
* CulDSac  Cul-de-sac
* FR2  Frontage on 2 sides of property
* FR3  Frontage on 3 sides of property

應該不是有次序的變數，把它轉成factor。

```{r LotConfig}
all$LotConfig %<>% as.factor()
table(all$LotConfig)

```


###Garage
####GarageYrBlt


